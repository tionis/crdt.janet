<html data-darkreader-mode=dynamic data-darkreader-scheme=dark data-lt-installed=true style><!--
 Page saved with SingleFile 
 url: https://braid.org/antimatter 
 saved date: Mon Jun 19 2023 18:32:05 GMT+0200 (Central European Summer Time)
--><meta charset=utf-8><style class="darkreader darkreader--invert" media=screen>:root{--darkreader-neutral-background:#131516;--darkreader-neutral-text:#d8d4cf;--darkreader-selection-background:#004daa;--darkreader-selection-text:#e8e6e3}::placeholder{opacity:0.5!important}.jfk-bubble.gtx-bubble,.captcheck_answer_label>input+img,span#closed_text>img[src^="https://www.gstatic.com/images/branding/googlelogo"],span[data-href^="https://www.hcaptcha.com/"]>#icon,#bit-notification-bar-iframe,::-webkit-calendar-picker-indicator{filter:invert(100%) hue-rotate(180deg) contrast(90%)!important}</style><title>Antimatter: an algorithm that prunes CRDT/OT history</title><style class="darkreader darkreader--user-agent" media=screen>.jfk-bubble.gtx-bubble,.captcheck_answer_label>input+img,span#closed_text>img[src^="https://www.gstatic.com/images/branding/googlelogo"],span[data-href^="https://www.hcaptcha.com/"]>#icon,#bit-notification-bar-iframe,::-webkit-calendar-picker-indicator{filter:invert(100%) hue-rotate(180deg) contrast(90%)!important}[data-darkreader-inline-bgcolor]{background-color:var(--darkreader-inline-bgcolor)!important}[data-darkreader-inline-bgimage]{background-image:var(--darkreader-inline-bgimage)!important}:root{--darkreader-neutral-background:#131516;--darkreader-neutral-text:#d8d4cf;--darkreader-selection-background:#004daa;--darkreader-selection-text:#e8e6e3}html{background-color:#181a1b!important}html{color-scheme:dark!important}html,body{background-color:#181a1b}html,body{border-color:#736b5e;color:#e8e6e3}a{color:#3391ff}::placeholder{color:#b2aba1}input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{background-color:#404400!important;color:#e8e6e3!important}::-webkit-scrollbar{background-color:#202324;color:#aba499}::-webkit-scrollbar-thumb{background-color:#454a4d}::-webkit-scrollbar-corner{background-color:#181a1b}*{scrollbar-color:#454a4d #202324}::selection{background-color:#004daa!important;color:#e8e6e3!important}::-moz-selection{background-color:#004daa!important;color:#e8e6e3!important}</style><style>.pad_me p{padding-left:10px;padding-right:10px}.pad_me h1{padding-left:10px;padding-right:10px}</style><meta name=darkreader content=94011b20c38244cca075180ab1c86f68><style class="darkreader darkreader--override" media=screen>::placeholder{opacity:0.5!important}</style><style>/*!
  Theme: Default
  Description: Original highlight.js style
  Author: (c) Ivan Sagalaev <maniac@softwaremaniacs.org>
  Maintainer: @highlightjs/core-team
  Website: https://highlightjs.org/
  License: see project LICENSE
  Touched: 2021
*/.hljs-comment{color:#888}.hljs-keyword{font-weight:700}.hljs-number,.hljs-string{color:#800}.hljs-title{color:#800;font-weight:700}.hljs-regexp,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-built_in{color:#397300}</style><style class="darkreader darkreader--sync" media=screen>.hljs-comment{color:#888}.hljs-keyword{font-weight:700}.hljs-number,.hljs-string{color:#800}.hljs-title{color:#800;font-weight:700}.hljs-regexp,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-built_in{color:#397300}.hljs-comment{color:rgb(157,148,136)}.hljs-number,.hljs-string{color:rgb(255,109,109)}.hljs-title{color:rgb(255,109,109)}.hljs-regexp,.hljs-variable{color:rgb(193,108,108)}.hljs-literal{color:rgb(132,177,111)}.hljs-built_in{color:rgb(189,255,124)}</style><link type=image/x-icon rel="shortcut icon" href=data:,><link rel=canonical href=https://braid.org/antimatter><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body style=margin:0px;font-family:Helvetica,Arial>
<testo style=display:none># Software Architecture
The software is architected into three objects:
```js
var {create_antimatter_crdt, create_json_crdt, sequence_crdt} = require('@braidjs/antimatter')
```
- *antimatter_crdt*: created using `create_antimatter_crdt`, this object is a json_crdt with antimatter algorithm methods added to it so that it can communicate with other peers to learn which history can be pruned, and tells the underlying json_crdt object to prune it.
- *json_crdt*: created using `create_json_crdt`, this object is a pruneable JSON CRDT — "JSON" meaning it represents an arbitrary JSON datstructure, and "CRDT" and "pruneable" having the same meaning as for sequence_crdt below. The json_crdt makes recursive use of sequence_crdt structures to represent arbitrary JSON (for instance, a map is represented with a sequence_crdt structure for each value, where the first element in the sequence is the value).
- *sequence_crdt*: methods to manipulate a pruneable sequence CRDT — "sequence" meaning it represents a javascript string or array, "CRDT" meaning this structure can be merged with other ones, and "pruneable" meaning that it supports an operation to remove meta-data when it is no longer needed (whereas CRDT's often keep track of this meta-data forever).
# create_antimatter_crdt(send[, init])
Creates and returns a new antimatter_crdt object (or adds antimatter_crdt methods and properties to `init`).
* `send`: A callback function to be called whenever this antimatter_crdt wants to send a message over a connection registered with `get` or `connect`. The sole parameter to this function is a JSONafiable object that hopes to be passed to the `receive` method on the antimatter_crdt object at the other end of the connection specified in the `conn` key.
* `init`: (optional) An antimatter_crdt object to start with, which we'll add any properties to that it doesn't have, and we'll add all the antimatter_crdt methods to it. This option exists so you can serialize an antimatter_crdt instance as JSON, and then restore it later.
``` js
var antimatter_crdt = create_antimatter_crdt(msg =&gt; {
 websockets[msg.conn].send(JSON.stringify(msg))
}, JSON.parse(fs.readFileSync('./antimatter.backup')))
```
# antimatter_crdt.receive(message)
Let this antimatter object "receive" a message from another antimatter object, presumably from its `send` callback.
``` js
websocket.on('message', data =&gt; {
 antimatter_crdt.receive(JSON.parse(data))
});
```
You generally do not need to mess with a message object directly, but below are the various message objects you might see, categorized by their `cmd` entry. Note that each object also contains a `conn` entry with the id of the connection the message is sent over.
## message `fissure`
Sent to alert peers about a fissure. The `fissure` entry contains information about the two peers involved in the fissure, the specific connection id that broke, the `versions` that need to be protected, and the `time` of the fissure (in case we want to ignore it after some time). It is also possible to send multiple `fissures` in an array.
``` js
{
 cmd: 'fissure',
 fissure: { // or fissures: [{...}, {...}, ...],
 a: 'PEER_A_ID',
 b: 'PEER_B_ID',
 conn: 'CONN_ID',
 versions: {'VERSION_ID': true, ...},
 time: Date.now()
 },
 conn: 'CONN_ID'
}
```
Note that `time` isn't used for anything critical, as it's just wallclock time.
## message `get`
`get` is the first message sent over a connection, and the peer at the other end will respond with `welcome`.
``` js
{
 cmd: 'get',
 peer: 'SENDER_ID',
 conn: 'CONN_ID',
 parents: {'PARENT_VERSION_ID': true, ...}
}
```
The `parents` are optional, and describes which versions this peer already has. The other end will respond with versions since that set of parents.
## message `forget`
Used to disconnect without creating a fissure, presumably meaning the sending peer doesn't plan to make any edits while they're disconnected.
``` js
{cmd: 'forget', conn: 'CONN_ID'}
```
## message forget `ack`
Sent in response to `forget`.. so they know we forgot them.
``` js
{cmd: 'ack', forget: true, conn: 'CONN_ID'}
```
## message `set`
Sent to alert peers about a change in the document. The change is represented as a version, with a unique id, a set of parent versions (the most recent versions known before adding this version), and an array of patches, where the offsets in the patches do not take into account the application of other patches in the same array.
``` js
{
 cmd: 'set',
 version: 'VERSION_ID',
 parents: {'PARENT_VERSION_ID': true, ...},
 patches: [
 {range: '.json.path.a.b', content: 42}, ...
 ],
 conn: 'CONN_ID'
}
```
## message `marco`
Sent for pruning purposes, to try and establish whether everyone has seen the most recent versions. Note that a `set` message is treated as a `marco` message for the version being set.
``` js
{
 cmd: 'marco',
 version: 'MARCO_ID',
 versions: {'VERSION_ID_A': true, ...},
 conn: 'CONN_ID'
}
```
## message local `ack`
Sent in response to `set`, but not right away; a peer will first send the `set` over all its other connections, and only after they have all responded with a local `ack` – and we didn't see a `fissure` message while waiting – will the peer send a local `ack` over the originating connection.
``` js
{cmd: 'ack', seen: 'local', version: 'VERSION_ID', conn: 'CONN_ID'}
```
## message global `ack`
Sent after an originating peer has received a local `ack` over all its connections, or after any peer receives a global `ack`, so that everyone may come to know that this version has been seen by everyone in this peer group.
``` js
{cmd: 'ack', seen: 'global', version: 'VERSION_ID', conn: 'CONN_ID'}
```
## message `welcome`
Sent in response to a `get`, basically contains the initial state of the document; incoming `welcome` messages are also propagated over all our other connections (but only with information that was new to us, so that the propagation will eventually stop). When sent in response to a `get` (rather than being propogated), we include a `peer` entry with the id of the sending peer, so they know who we are, and to trigger them to send us their own `welcome` message.
``` js
{
 cmd: 'welcome',
 versions: [each version looks like a set message...],
 fissures: [each fissure looks as it would in a fissure message...],
 parents: {'PARENT_VERSION_ID': true,
 ...versions you must have before consuming these new versions},
 [ peer: 'SENDER_ID', ] // if sent in response to a get
 conn: 'CONN_ID'
}
```
# antimatter_crdt.get(conn) or connect(conn)
Register a new connection with id `conn` – triggers this antimatter_crdt object to send a `get` message over the given connection.
``` js
alice_antimatter_crdt.get('connection_to_bob')
```
# antimatter_crdt.forget(conn)
Disconnect the given connection without creating a fissure – we don't need to reconnect with them.. it seems.. if we do, then we need to call `disconnect` instead, which will create a fissure allowing us to reconnect.
``` js
alice_antimatter_crdt.forget('connection_to_bob')
```
# antimatter_crdt.disconnect(conn)
If we detect that a connection has closed, let the antimatter_crdt object know by calling this method with the given connection id – this will create a fissure so we can reconnect with whoever was on the other end of the connection later on.
``` js
alice_antimatter_crdt.disconnect('connection_to_bob')
```
# antimatter_crdt.set(...patches)
Modify this antimatter_crdt object by applying the given patches. Each patch looks like `{range: '.life.meaning', content: 42}`. Calling this method will trigger calling the `send` callback to let our peers know about this change.
``` js
antimatter_crdt.set({range: '.life.meaning', content: 42})
```
# antimatter_crdt.marco()
Initiate sending a `marco` message to try and establish whether certain versions can be pruned.
``` js
antimatter_crdt.marco()
```
---
# create_json_crdt([init])
Create a new `json_crdt` object (or start with `init`, and add stuff to that).
``` js
var json_crdt = create_json_crdt()
```
# json_crdt.read()
Returns an instance of the `json` object represented by this json_crdt data-structure.
``` js
console.log(json_crdt.read())
```
# json_crdt.generate_braid(versions)
Returns an array of `set` messages that each look like this: `{version, parents, patches, sort_keys}`, such that if we pass all these messages to `antimatter_crdt.receive()`, we'll reconstruct the data in this `json_crdt` datastructure, assuming the recipient already has the given `versions` (which is represented as an object where each key is a version, and each value is `true`).
``` js
json_crdt.generate_braid({alice2: true, bob3: true})
```
# json_crdt.apply_bubbles(to_bubble)
This method helps prune away meta data and compress stuff when we have determined that certain versions can be renamed to other versions – these renamings are expressed in `to_bubble`, where keys are versions and values are "bubbles", each bubble represented with an array of two elements, the first element is the "bottom" of the bubble, and the second element is the "top" of the bubble; "bottom" and "top" make sense when viewing versions in a directed graph with the oldest version(s) at the top, and each version pointing up to it's parents. A bubble is then a set of versions where the only arrows leaving the bubble upward are from the "top" version, and the only arrows leaving the bubble downward are from the "bottom" version. This method effectively combines all the versions in a bubble into a single version, and may allow the data structure to be compressed, since now we don't need to distinguish between certain versions that we used to need to.
``` js
json_crdt.apply_bubbles({alice4: ['bob5', 'alice4'], bob5: ['bob5', 'alice4']})
```
# json_crdt.add_version(version, parents, patches[, sort_keys])
The main method for modifying a `json_crdt` data structure.
* `version`: Unique string associated with this edit.
* `parents`: A set of versions that this version is aware of, represented as a map with versions as keys, and values of `true`.
* `patches`: An array of patches, where each patch is an object like this `{range: '.life.meaning', content: 42}`.
* `sort_keys`: (optional) An object where each key is an index, and the value is a sort_key to use with the patch at the given index in the `patches` array – a sort_key overrides the version for a patch for the purposes of sorting. This can be useful after doing some pruning.
``` js
json_crdt.add_version('alice6',
 {alice5: true, bob7: true},
 [{range: '.a.b', content: 'c'}])
```
# json_crdt.get_child_map()
Returns a map where each key is a version, and each value is a set of child versions, represented as a map with versions as keys, and values of `true`.
``` js
json_crdt.get_child_map()
```
# json_crdt.ancestors(versions, ignore_nonexistent=false)
Gather `versions` and all their ancestors into a set. `versions` is a set of versions, i.e. a map with version-keys and values of true – we'll basically return a larger set. If `ignore_nonexistent` is `true`, then we won't throw an exception if we encounter a version that we don't have in our datastructure.
``` js
json_crdt.ancestors({alice12: true, bob10: true})
```
# json_crdt.descendants(versions, ignore_nonexistent=false)
Gather `versions` and all their descendants into a set. `versions` is a set of versions, i.e. a map with version-keys and values of true – we'll basically return a larger set. If `ignore_nonexistent` is `true`, then we won't throw an exception if we encounter a version that we don't have in our datastructure.
``` js
json_crdt.descendants({alice12: true, bob10: true})
```
# json_crdt.get_leaves(versions)
Returns a set of versions from `versions` which don't also have a child in `versions`. `versions` is itself a set of versions, represented as an object with version keys and `true` values, and the return value is represented the same way.
# json_crdt.parse_patch(patch)
Takes a patch in the form `{range, content}`, and returns an object of the form `{path: [...], [slice: [...]], [delete: true], content}`; basically calling `parse_json_path` on `patch.range`, and adding `patch.content` along for the ride.
# json_crdt.parse_json_path(json_path)
Parses the string `json_path` into an object like: `{path: [...], [slice: [...]], [delete: true]}`.
* `a.b[3]` --&gt; `{path: ['a', 'b', 3]}`
* `a.b[3:5]` --&gt; `{path: ['a', 'b'], slice: [3, 5]}`
* `delete a.b` --&gt; `{path: ['a', 'b'], delete: true}`
``` js
console.log(json_crdt.parse_json_path('a.b.c'))
```
---
# sequence_crdt.create_node(version, elems, [end_cap, sort_key])
Creates a node for a `sequence_crdt` sequence CRDT with the given properties. The resulting node will look like this:
``` js
{
 version, // globally unique string
 elems, // a string or array representing actual data elements of the underlying sequence
 end_cap, // this is useful for dealing with replace operations
 sort_key, // version to pretend this is for the purposes of sorting
 deleted_by : {}, // if this node gets deleted, we'll mark it here
 nexts : [], // array of nodes following this one
 next : null // final node following this one (after all the nexts)
}
var sequence_node = sequence_crdt.create_node('alice1', 'hello')
```
# sequence_crdt.generate_braid(root_node, version, is_anc)
Reconstructs an array of splice-information which can be passed to `sequence_crdt.add_version` in order to add `version` to another `sequence_crdt` instance – the returned array looks like: `[[insert_pos, delete_count, insert_elems, sort_key], ...]`. `is_anc` is a function which accepts a version string and returns `true` if and only if the given version is an ancestor of `version` (i.e. a version which the author of `version` knew about when they created that version).
``` js
var root_node = sequence_crdt.create_node('alice1', 'hello')
console.log(sequence_crdt.generate_braid(root_node, 'alice1', x =&gt; false)) // outputs [0, 0, "hello"]
```
# sequence_crdt.apply_bubbles(root_node, to_bubble)
This method helps prune away meta data and compress stuff when we have determined that certain versions can be renamed to other versions – these renamings are expressed in `to_bubble`, where keys are versions and values are "bubbles", each bubble represented with an array of two elements, the first element is the "bottom" of the bubble, and the second element is the "top" of the bubble. We will rename the given version to the "bottom" of the bubble. "bottom" and "top" make sense when viewing versions in a directed graph with the oldest version(s) at the top, and each version pointing up to it's parents. A bubble is then a set of versions where the only arrows leaving the bubble upward are from the "top" version, and the only arrows leaving the bubble downward are from the "bottom" version. This method effectively combines all the versions in a bubble into a single version, and may allow the data structure to be compressed, since now we don't need to distinguish between certain versions that we used to need to.
``` js
sequence_crdt.apply_bubbles(root_node, {alice4: ['bob5', 'alice4'], bob5: ['bob5', 'alice4']})
```
# sequence_crdt.get(root_node, i, is_anc)
Returns the element at the `i`th position (0-based) in the `sequence_crdt` rooted at `root_node`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
var x = sequence_crdt.get(root_node, 2, {alice1: true})
```
# sequence_crdt.set(root_node, i, v, is_anc)
Sets the element at the `i`th position (0-based) in the `sequence_crdt` rooted at `root_node` to the value `v`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
sequence_crdt.set(root_node, 2, 'x', {alice1: true})
```
# sequence_crdt.length(root_node, is_anc)
Returns the length of the `sequence_crdt` rooted at `root_node`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
console.log(sequence_crdt.length(root_node, {alice1: true}))
```
# sequence_crdt.break_node(node, break_position, end_cap, new_next)
This method breaks apart a `sequence_crdt` node into two nodes, each representing a subsequence of the sequence represented by the original node; the `node` parameter is modified into the first node, and the second node is returned. The first node represents the elements of the sequence before `break_position`, and the second node represents the rest of the elements. If `end_cap` is truthy, then the first node will have `end_cap` set – this is generally done if the elements in the second node are being replaced. This method will add `new_next` to the first node's `nexts` array.
``` js
var node = sequence_crdt.create_node('alice1', 'hello')
// node node.elems == 'hello'
var second = sequence_crdt.break_node(node, 2)
// now node.elems == 'he',
// and second.elems == 'llo'
```
# sequence_crdt.add_version(root_node, version, splices, [is_anc])
This is the main method of `sequence_crdt`, used to modify the sequence. The modification must be given a unique `version` string, and the modification itself is represented as an array of `splices`, where each splice looks like this: `[position, num_elements_to_delete, elements_to_insert, optional_sort_key]`. Note that all positions are relative to the original sequence, before any splices have been applied. Positions are counted by only considering nodes with versions which result in `true` when passed to `is_anc` (and are not `deleted_by` any versions which return `true` when passed to `is_anc`).
``` js
var node = sequence_crdt.create_node('alice1', 'hello')
sequence_crdt.add_version(node, 'alice2', [[5, 0, ' world']], null, v =&gt; v == 'alice1')
```
# sequence_crdt.traverse(root_node, is_anc, callback, [view_deleted, tail_callback])
Traverses the subset of nodes in the tree rooted at `root_node` whos versions return `true` when passed to `is_anc`. For each node, `callback` is called with these parameters: `node, offset, has_nexts, prev, version, deleted`, where `node` is the current node being traversed; `offset` says how many elements we have passed so far getting here; `has_nexts` is true if some of this node's `nexts` will be traversed according to `is_anc`; `prev` is a pointer to the node whos `next` points to this one, or `null` if this is the root node; `version` is the version of this node, or this node's `prev` if our version is `null`, or that node's `prev` if it is also `null`, etc; `deleted` is true if this node is deleted according to `is_anc` (usually we skip deleted nodes when traversing, but we'll include them if `view_deleted` is `true`). `tail_callback` is an optional callback that will get called with a single parameter `node` after all of that node's children `nexts` and `next` have been traversed.
``` js
sequence_crdt.traverse(node, () =&gt; true, node =&gt; process.stdout.write(node.elems))
```
</testo>
<div class=pad_me style=width:100%;box-sizing:border-box>
 <div id=vis_holder style=width:50%;height:100%;float:right;padding-left:0px;padding-right:0px><iframe style=width:100%;height:100%;padding-left:0px;padding-right:0px sandbox="allow-popups allow-top-navigation allow-top-navigation-by-user-activation allow-scripts allow-same-origin" srcdoc="<html data-darkreader-mode=dynamic data-darkreader-scheme=dark data-lt-installed=true><meta charset=utf-8><style class=&quot;darkreader darkreader--user-agent&quot; media=screen>.jfk-bubble.gtx-bubble,.captcheck_answer_label>input+img,span#closed_text>img[src^=&quot;https://www.gstatic.com/images/branding/googlelogo&quot;],span[data-href^=&quot;https://www.hcaptcha.com/&quot;]>#icon,#bit-notification-bar-iframe,::-webkit-calendar-picker-indicator{filter:invert(100%) hue-rotate(180deg) contrast(90%)!important}[data-darkreader-inline-bgcolor]{background-color:var(--darkreader-inline-bgcolor)!important}[data-darkreader-inline-bgimage]{background-image:var(--darkreader-inline-bgimage)!important}[data-darkreader-inline-border-bottom]{border-bottom-color:var(--darkreader-inline-border-bottom)!important}[data-darkreader-inline-border-left]{border-left-color:var(--darkreader-inline-border-left)!important}[data-darkreader-inline-border-right]{border-right-color:var(--darkreader-inline-border-right)!important}[data-darkreader-inline-border-top]{border-top-color:var(--darkreader-inline-border-top)!important}[data-darkreader-inline-color]{color:var(--darkreader-inline-color)!important}:root{--darkreader-neutral-background:#131516;--darkreader-neutral-text:#d8d4cf;--darkreader-selection-background:#004daa;--darkreader-selection-text:#e8e6e3}html{color-scheme:dark!important}html,body{border-color:#736b5e;color:#e8e6e3}::placeholder{color:#b2aba1}input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{background-color:#404400!important;color:#e8e6e3!important}::-webkit-scrollbar{background-color:#202324;color:#aba499}::-webkit-scrollbar-thumb{background-color:#454a4d}::-webkit-scrollbar-corner{background-color:#181a1b}*{scrollbar-color:#454a4d #202324}::selection{background-color:#004daa!important;color:#e8e6e3!important}::-moz-selection{background-color:#004daa!important;color:#e8e6e3!important}</style><meta name=darkreader content=fae40948298843849d03c81e4c3361aa><style class=&quot;darkreader darkreader--override&quot; media=screen>::placeholder{opacity:0.5!important}</style><meta http-equiv=content-security-policy content=&quot;default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;&quot;><style>img[src=&quot;data:,&quot;],source[src=&quot;data:,&quot;]{display:none!important}</style></head>
<body style=margin:0px;font-family:Helvetica,Arial>
<testo style=display:none># Software Architecture
The software is architected into three objects:
```js
var {create_antimatter_crdt, create_json_crdt, sequence_crdt} = require('@braidjs/antimatter')
```
- *antimatter_crdt*: created using `create_antimatter_crdt`, this object is a json_crdt with antimatter algorithm methods added to it so that it can communicate with other peers to learn which history can be pruned, and tells the underlying json_crdt object to prune it.
- *json_crdt*: created using `create_json_crdt`, this object is a pruneable JSON CRDT — &quot;JSON&quot; meaning it represents an arbitrary JSON datstructure, and &quot;CRDT&quot; and &quot;pruneable&quot; having the same meaning as for sequence_crdt below. The json_crdt makes recursive use of sequence_crdt structures to represent arbitrary JSON (for instance, a map is represented with a sequence_crdt structure for each value, where the first element in the sequence is the value).
- *sequence_crdt*: methods to manipulate a pruneable sequence CRDT — &quot;sequence&quot; meaning it represents a javascript string or array, &quot;CRDT&quot; meaning this structure can be merged with other ones, and &quot;pruneable&quot; meaning that it supports an operation to remove meta-data when it is no longer needed (whereas CRDT's often keep track of this meta-data forever).
# create_antimatter_crdt(send[, init])
Creates and returns a new antimatter_crdt object (or adds antimatter_crdt methods and properties to `init`).
* `send`: A callback function to be called whenever this antimatter_crdt wants to send a message over a connection registered with `get` or `connect`. The sole parameter to this function is a JSONafiable object that hopes to be passed to the `receive` method on the antimatter_crdt object at the other end of the connection specified in the `conn` key.
* `init`: (optional) An antimatter_crdt object to start with, which we'll add any properties to that it doesn't have, and we'll add all the antimatter_crdt methods to it. This option exists so you can serialize an antimatter_crdt instance as JSON, and then restore it later.
``` js
var antimatter_crdt = create_antimatter_crdt(msg =&amp;gt; {
 websockets[msg.conn].send(JSON.stringify(msg))
}, JSON.parse(fs.readFileSync('./antimatter.backup')))
```
# antimatter_crdt.receive(message)
Let this antimatter object &quot;receive&quot; a message from another antimatter object, presumably from its `send` callback.
``` js
websocket.on('message', data =&amp;gt; {
 antimatter_crdt.receive(JSON.parse(data))
});
```
You generally do not need to mess with a message object directly, but below are the various message objects you might see, categorized by their `cmd` entry. Note that each object also contains a `conn` entry with the id of the connection the message is sent over.
## message `fissure`
Sent to alert peers about a fissure. The `fissure` entry contains information about the two peers involved in the fissure, the specific connection id that broke, the `versions` that need to be protected, and the `time` of the fissure (in case we want to ignore it after some time). It is also possible to send multiple `fissures` in an array.
``` js
{
 cmd: 'fissure',
 fissure: { // or fissures: [{...}, {...}, ...],
 a: 'PEER_A_ID',
 b: 'PEER_B_ID',
 conn: 'CONN_ID',
 versions: {'VERSION_ID': true, ...},
 time: Date.now()
 },
 conn: 'CONN_ID'
}
```
Note that `time` isn't used for anything critical, as it's just wallclock time.
## message `get`
`get` is the first message sent over a connection, and the peer at the other end will respond with `welcome`.
``` js
{
 cmd: 'get',
 peer: 'SENDER_ID',
 conn: 'CONN_ID',
 parents: {'PARENT_VERSION_ID': true, ...}
}
```
The `parents` are optional, and describes which versions this peer already has. The other end will respond with versions since that set of parents.
## message `forget`
Used to disconnect without creating a fissure, presumably meaning the sending peer doesn't plan to make any edits while they're disconnected.
``` js
{cmd: 'forget', conn: 'CONN_ID'}
```
## message forget `ack`
Sent in response to `forget`.. so they know we forgot them.
``` js
{cmd: 'ack', forget: true, conn: 'CONN_ID'}
```
## message `set`
Sent to alert peers about a change in the document. The change is represented as a version, with a unique id, a set of parent versions (the most recent versions known before adding this version), and an array of patches, where the offsets in the patches do not take into account the application of other patches in the same array.
``` js
{
 cmd: 'set',
 version: 'VERSION_ID',
 parents: {'PARENT_VERSION_ID': true, ...},
 patches: [
 {range: '.json.path.a.b', content: 42}, ...
 ],
 conn: 'CONN_ID'
}
```
## message `marco`
Sent for pruning purposes, to try and establish whether everyone has seen the most recent versions. Note that a `set` message is treated as a `marco` message for the version being set.
``` js
{
 cmd: 'marco',
 version: 'MARCO_ID',
 versions: {'VERSION_ID_A': true, ...},
 conn: 'CONN_ID'
}
```
## message local `ack`
Sent in response to `set`, but not right away; a peer will first send the `set` over all its other connections, and only after they have all responded with a local `ack` – and we didn't see a `fissure` message while waiting – will the peer send a local `ack` over the originating connection.
``` js
{cmd: 'ack', seen: 'local', version: 'VERSION_ID', conn: 'CONN_ID'}
```
## message global `ack`
Sent after an originating peer has received a local `ack` over all its connections, or after any peer receives a global `ack`, so that everyone may come to know that this version has been seen by everyone in this peer group.
``` js
{cmd: 'ack', seen: 'global', version: 'VERSION_ID', conn: 'CONN_ID'}
```
## message `welcome`
Sent in response to a `get`, basically contains the initial state of the document; incoming `welcome` messages are also propagated over all our other connections (but only with information that was new to us, so that the propagation will eventually stop). When sent in response to a `get` (rather than being propogated), we include a `peer` entry with the id of the sending peer, so they know who we are, and to trigger them to send us their own `welcome` message.
``` js
{
 cmd: 'welcome',
 versions: [each version looks like a set message...],
 fissures: [each fissure looks as it would in a fissure message...],
 parents: {'PARENT_VERSION_ID': true,
 ...versions you must have before consuming these new versions},
 [ peer: 'SENDER_ID', ] // if sent in response to a get
 conn: 'CONN_ID'
}
```
# antimatter_crdt.get(conn) or connect(conn)
Register a new connection with id `conn` – triggers this antimatter_crdt object to send a `get` message over the given connection.
``` js
alice_antimatter_crdt.get('connection_to_bob')
```
# antimatter_crdt.forget(conn)
Disconnect the given connection without creating a fissure – we don't need to reconnect with them.. it seems.. if we do, then we need to call `disconnect` instead, which will create a fissure allowing us to reconnect.
``` js
alice_antimatter_crdt.forget('connection_to_bob')
```
# antimatter_crdt.disconnect(conn)
If we detect that a connection has closed, let the antimatter_crdt object know by calling this method with the given connection id – this will create a fissure so we can reconnect with whoever was on the other end of the connection later on.
``` js
alice_antimatter_crdt.disconnect('connection_to_bob')
```
# antimatter_crdt.set(...patches)
Modify this antimatter_crdt object by applying the given patches. Each patch looks like `{range: '.life.meaning', content: 42}`. Calling this method will trigger calling the `send` callback to let our peers know about this change.
``` js
antimatter_crdt.set({range: '.life.meaning', content: 42})
```
# antimatter_crdt.marco()
Initiate sending a `marco` message to try and establish whether certain versions can be pruned.
``` js
antimatter_crdt.marco()
```
---
# create_json_crdt([init])
Create a new `json_crdt` object (or start with `init`, and add stuff to that).
``` js
var json_crdt = create_json_crdt()
```
# json_crdt.read()
Returns an instance of the `json` object represented by this json_crdt data-structure.
``` js
console.log(json_crdt.read())
```
# json_crdt.generate_braid(versions)
Returns an array of `set` messages that each look like this: `{version, parents, patches, sort_keys}`, such that if we pass all these messages to `antimatter_crdt.receive()`, we'll reconstruct the data in this `json_crdt` datastructure, assuming the recipient already has the given `versions` (which is represented as an object where each key is a version, and each value is `true`).
``` js
json_crdt.generate_braid({alice2: true, bob3: true})
```
# json_crdt.apply_bubbles(to_bubble)
This method helps prune away meta data and compress stuff when we have determined that certain versions can be renamed to other versions – these renamings are expressed in `to_bubble`, where keys are versions and values are &quot;bubbles&quot;, each bubble represented with an array of two elements, the first element is the &quot;bottom&quot; of the bubble, and the second element is the &quot;top&quot; of the bubble; &quot;bottom&quot; and &quot;top&quot; make sense when viewing versions in a directed graph with the oldest version(s) at the top, and each version pointing up to it's parents. A bubble is then a set of versions where the only arrows leaving the bubble upward are from the &quot;top&quot; version, and the only arrows leaving the bubble downward are from the &quot;bottom&quot; version. This method effectively combines all the versions in a bubble into a single version, and may allow the data structure to be compressed, since now we don't need to distinguish between certain versions that we used to need to.
``` js
json_crdt.apply_bubbles({alice4: ['bob5', 'alice4'], bob5: ['bob5', 'alice4']})
```
# json_crdt.add_version(version, parents, patches[, sort_keys])
The main method for modifying a `json_crdt` data structure.
* `version`: Unique string associated with this edit.
* `parents`: A set of versions that this version is aware of, represented as a map with versions as keys, and values of `true`.
* `patches`: An array of patches, where each patch is an object like this `{range: '.life.meaning', content: 42}`.
* `sort_keys`: (optional) An object where each key is an index, and the value is a sort_key to use with the patch at the given index in the `patches` array – a sort_key overrides the version for a patch for the purposes of sorting. This can be useful after doing some pruning.
``` js
json_crdt.add_version('alice6',
 {alice5: true, bob7: true},
 [{range: '.a.b', content: 'c'}])
```
# json_crdt.get_child_map()
Returns a map where each key is a version, and each value is a set of child versions, represented as a map with versions as keys, and values of `true`.
``` js
json_crdt.get_child_map()
```
# json_crdt.ancestors(versions, ignore_nonexistent=false)
Gather `versions` and all their ancestors into a set. `versions` is a set of versions, i.e. a map with version-keys and values of true – we'll basically return a larger set. If `ignore_nonexistent` is `true`, then we won't throw an exception if we encounter a version that we don't have in our datastructure.
``` js
json_crdt.ancestors({alice12: true, bob10: true})
```
# json_crdt.descendants(versions, ignore_nonexistent=false)
Gather `versions` and all their descendants into a set. `versions` is a set of versions, i.e. a map with version-keys and values of true – we'll basically return a larger set. If `ignore_nonexistent` is `true`, then we won't throw an exception if we encounter a version that we don't have in our datastructure.
``` js
json_crdt.descendants({alice12: true, bob10: true})
```
# json_crdt.get_leaves(versions)
Returns a set of versions from `versions` which don't also have a child in `versions`. `versions` is itself a set of versions, represented as an object with version keys and `true` values, and the return value is represented the same way.
# json_crdt.parse_patch(patch)
Takes a patch in the form `{range, content}`, and returns an object of the form `{path: [...], [slice: [...]], [delete: true], content}`; basically calling `parse_json_path` on `patch.range`, and adding `patch.content` along for the ride.
# json_crdt.parse_json_path(json_path)
Parses the string `json_path` into an object like: `{path: [...], [slice: [...]], [delete: true]}`.
* `a.b[3]` --&amp;gt; `{path: ['a', 'b', 3]}`
* `a.b[3:5]` --&amp;gt; `{path: ['a', 'b'], slice: [3, 5]}`
* `delete a.b` --&amp;gt; `{path: ['a', 'b'], delete: true}`
``` js
console.log(json_crdt.parse_json_path('a.b.c'))
```
---
# sequence_crdt.create_node(version, elems, [end_cap, sort_key])
Creates a node for a `sequence_crdt` sequence CRDT with the given properties. The resulting node will look like this:
``` js
{
 version, // globally unique string
 elems, // a string or array representing actual data elements of the underlying sequence
 end_cap, // this is useful for dealing with replace operations
 sort_key, // version to pretend this is for the purposes of sorting
 deleted_by : {}, // if this node gets deleted, we'll mark it here
 nexts : [], // array of nodes following this one
 next : null // final node following this one (after all the nexts)
}
var sequence_node = sequence_crdt.create_node('alice1', 'hello')
```
# sequence_crdt.generate_braid(root_node, version, is_anc)
Reconstructs an array of splice-information which can be passed to `sequence_crdt.add_version` in order to add `version` to another `sequence_crdt` instance – the returned array looks like: `[[insert_pos, delete_count, insert_elems, sort_key], ...]`. `is_anc` is a function which accepts a version string and returns `true` if and only if the given version is an ancestor of `version` (i.e. a version which the author of `version` knew about when they created that version).
``` js
var root_node = sequence_crdt.create_node('alice1', 'hello')
console.log(sequence_crdt.generate_braid(root_node, 'alice1', x =&amp;gt; false)) // outputs [0, 0, &quot;hello&quot;]
```
# sequence_crdt.apply_bubbles(root_node, to_bubble)
This method helps prune away meta data and compress stuff when we have determined that certain versions can be renamed to other versions – these renamings are expressed in `to_bubble`, where keys are versions and values are &quot;bubbles&quot;, each bubble represented with an array of two elements, the first element is the &quot;bottom&quot; of the bubble, and the second element is the &quot;top&quot; of the bubble. We will rename the given version to the &quot;bottom&quot; of the bubble. &quot;bottom&quot; and &quot;top&quot; make sense when viewing versions in a directed graph with the oldest version(s) at the top, and each version pointing up to it's parents. A bubble is then a set of versions where the only arrows leaving the bubble upward are from the &quot;top&quot; version, and the only arrows leaving the bubble downward are from the &quot;bottom&quot; version. This method effectively combines all the versions in a bubble into a single version, and may allow the data structure to be compressed, since now we don't need to distinguish between certain versions that we used to need to.
``` js
sequence_crdt.apply_bubbles(root_node, {alice4: ['bob5', 'alice4'], bob5: ['bob5', 'alice4']})
```
# sequence_crdt.get(root_node, i, is_anc)
Returns the element at the `i`th position (0-based) in the `sequence_crdt` rooted at `root_node`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
var x = sequence_crdt.get(root_node, 2, {alice1: true})
```
# sequence_crdt.set(root_node, i, v, is_anc)
Sets the element at the `i`th position (0-based) in the `sequence_crdt` rooted at `root_node` to the value `v`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
sequence_crdt.set(root_node, 2, 'x', {alice1: true})
```
# sequence_crdt.length(root_node, is_anc)
Returns the length of the `sequence_crdt` rooted at `root_node`, when only considering versions which result in `true` when passed to `is_anc`.
``` js
console.log(sequence_crdt.length(root_node, {alice1: true}))
```
# sequence_crdt.break_node(node, break_position, end_cap, new_next)
This method breaks apart a `sequence_crdt` node into two nodes, each representing a subsequence of the sequence represented by the original node; the `node` parameter is modified into the first node, and the second node is returned. The first node represents the elements of the sequence before `break_position`, and the second node represents the rest of the elements. If `end_cap` is truthy, then the first node will have `end_cap` set – this is generally done if the elements in the second node are being replaced. This method will add `new_next` to the first node's `nexts` array.
``` js
var node = sequence_crdt.create_node('alice1', 'hello')
// node node.elems == 'hello'
var second = sequence_crdt.break_node(node, 2)
// now node.elems == 'he',
// and second.elems == 'llo'
```
# sequence_crdt.add_version(root_node, version, splices, [is_anc])
This is the main method of `sequence_crdt`, used to modify the sequence. The modification must be given a unique `version` string, and the modification itself is represented as an array of `splices`, where each splice looks like this: `[position, num_elements_to_delete, elements_to_insert, optional_sort_key]`. Note that all positions are relative to the original sequence, before any splices have been applied. Positions are counted by only considering nodes with versions which result in `true` when passed to `is_anc` (and are not `deleted_by` any versions which return `true` when passed to `is_anc`).
``` js
var node = sequence_crdt.create_node('alice1', 'hello')
sequence_crdt.add_version(node, 'alice2', [[5, 0, ' world']], null, v =&amp;gt; v == 'alice1')
```
# sequence_crdt.traverse(root_node, is_anc, callback, [view_deleted, tail_callback])
Traverses the subset of nodes in the tree rooted at `root_node` whos versions return `true` when passed to `is_anc`. For each node, `callback` is called with these parameters: `node, offset, has_nexts, prev, version, deleted`, where `node` is the current node being traversed; `offset` says how many elements we have passed so far getting here; `has_nexts` is true if some of this node's `nexts` will be traversed according to `is_anc`; `prev` is a pointer to the node whos `next` points to this one, or `null` if this is the root node; `version` is the version of this node, or this node's `prev` if our version is `null`, or that node's `prev` if it is also `null`, etc; `deleted` is true if this node is deleted according to `is_anc` (usually we skip deleted nodes when traversing, but we'll include them if `view_deleted` is `true`). `tail_callback` is an optional callback that will get called with a single parameter `node` after all of that node's children `nexts` and `next` have been traversed.
``` js
sequence_crdt.traverse(node, () =&amp;gt; true, node =&amp;gt; process.stdout.write(node.elems))
```
</testo>
<div style=width:100%;height:100%;position:relative;background:rgb(36,36,36);--darkreader-inline-bgcolor:#1b1d1e;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage><canvas style=&quot;width:100%;height:100%;background-blend-mode:normal!important;background-clip:content-box!important;background-position:center center!important;background-color:transparent!important;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0QAAANuCAYAAAA2Lsl+AAAgAElEQVR4XuydB3gUVffGbzoJJQmd0PnoSBOkKgT921AEhIgInwQ/FVBBUEFQVBCVIkqxoaAEkaIgTSmKaEBFQHqTTmgBQgmhJCH1/55lJk42m2Q32U12s+88z3y7M3PLub/Zz9yXc+65HooHCZAACZAACZAACZAACZAACbgpAQ83HTeHTQIkQAIkQAIkQAIkQAIkQAKKgog/AhIgARIgARIgARIgARIgAbclQEHktq+eAycBEiABEiABEiABEiABEqAg4m+ABEiABEiABEiABEiABEjAbQlQELntq+fASYAESIAESIAESIAESIAEKIj4GyABEiABEiABEiABEiABEnBbAhREbvvqOXASIAESIAESIAESIAESIAEKIv4GSIAESIAESIAESIAESIAE3JYABZHbvnoOnARIgARIgARIgARIgARIgIKIvwESIAESIAESIAESIAESIAG3JUBB5LavngMnARIgARIgARIgARIgARKgIOJvgARIgARIgARIgARIgARIwG0JUBC57avnwEmABEiABEiABEiABEiABCiI+BsgARIgARIgARIgARIgARJwWwIURG776jlwEiABEiABEiABEiABEiABCiL+BkiABEiABEiABEiABEiABNyWAAWR2756DpwESIAESIAESIAESIAESICCiL8BEiABEiABEiABEiABEiABtyVAQeS2r54DJwESIAESIAESIAESIAESoCDib4AESIAESIAESIAESIAESMBtCVAQue2r58BJgARIgARIgARIgARIgAQoiPgbIAESIAESIAESIAESIAEScFsCFERu++o5cBIgARIgARIgARIgARIgAQoi/gZIgARIgARIgARIgARIgATclgAFkdu+eg6cBEiABEiABEiABEiABEiAgoi/ARIgARIggSJDID09PQiDmYIzFGcNbWBX8LkM51gPD4+oIjNYDoQESIAESMAuBCiI7IKRjZAACZAACRQ2AYghEUFLcYooyu7oD1EUUdi2sn8SIAESIAHnIUBB5DzvgpaQAAmQAAnkkQDEUDNU/S0XMaS3TlGUR86sRgIkQAJFkQAFUVF8qxwTCZAACbgZAQiiSAy5o5XDlhC6mvAUyScPEiABEiABNydAQeTmPwAOnwRIgARcnYDmHdph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43+PHj3aCym41ZgxY56pUaNG/379+t0m4X/ahP3Pb775Zg32U3oKwqeJJnxE5MXC7ldtEURoMwjrmvri7FK1alXxQOX5MHq20IhLhMsZBwtRdAA86mn3nDoZRJ5fEiuSAAmQQDYEKIj40yABEiABFyYAAXAfxICIolU410G8/CCiR4SSURBhiM1EuMhQz58/3xSiZRTKeUIcVUGdts8995yqU6fOlWHDhq2uUqVKf9SPhBiaId4lVPkTn5MgOO4xokKZpWhjKQTY18b7EEd1IY5W4X6d1atXTzt58uTgefPmqYiIiOSpU6cO3LFjx0eoF6AJnPgFCxb4lChRojz2GnoN64iGQ3wpiJ2EunXrbkOZwJ49e74CW35EHR+pEx4evueBBx74G/b8T65hRx989MH4OtsgiMR7IxntamP8N/L7E3D1sDOzUMXNEK5t8suE9UmABEjAVQhQELnKm6KdJEACJJANgZiYmBLwqHSEaHkERe6EELkdouITM0FUH4LBtM8MRNBBiItRuF4iYW+nT59OgCDygIdGffrpp5chTnrheWcUnSqhdfjciOsklJ9iJoiW4f4y9Bdhbpp4mCA23semqh+/+eabDSDC1Jw5c5IQLlcPnqEgPFuJuqZwvLlz56qXXnppHO438vHxefSjjz6S0K1pmJRnJE0wJizo2rWratq06fZ7771XwuZEED2hCaKH8D0ZYipYPEfgUhHC70g2IXPShw9s+NF8XLb+0MzC5dIhBiu5SricYaxe8BKdAI/Kcg9es7bICLjJVhYsTwIkQAKuSICCyBXfGm0mARIgAY2AJE8oVqzYPISynZaECRLahnCy27EG5y1Mbg9DrLwvIXMoniGIcB2Hawl1O4Hvz0JMfTx48GAfrClSCFdLQdjcarTxOequRPvbUfYyhMogiIzDRvDo6xX02RrthOGzGNpah5C5vvC4HMezB3FvJNosAbF1u9R79913T//nP/+ZKGF8y5Ytu6ts2bKrR40aVVwE0cCBAxXWAF0YOXJkOYgjdf369e4LFy68gDG0RPvTpD4m7DNwPUAEUceOHSWkrvfKlSsXot9PxUaUG43v52FDO7R1FDaIXbOzW0MEUbYRE3/JwtcXZf7I648KYu1x1JUNaXPdfDavfRREPeP+VOjPqTeVLQge7IMESMB9CFAQuc+75khJgASKIAFM+jtj0v8W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gAgkGwEJomQbcfVXBERABEQgvghcYQxAgycj+kxCs+6dVXzuwHN9+xEFEQZCFMnBQhDAlFQERCB5CEgQJc9Yq6ciIAIiIALxTIDWIoSqqVUFljgKojuaNhcELCUVARFILgISRMk13uqtCIiACIhAnBPAvkS09AS8gMjsrgRRnI+7mi8CIuAeAQki99iqZBEQAREQARGIOAEIIlqIzgiy4DMxZY75FERABERABBwEJIj0SIiACIiACIhAHBGAIKIb7SeCaPJBiCHfdDsFERABERCB4wlIEOmpEAEREAEREIE4IgBBRHHDaXPVnuf8NP92CKIn46iLaqoIiIAIRJWABFFUcasyERABERABEQifAEQRPc8VIDbzU9oUiKH88GtUCSIgAiKQuAQkiBJ3bNUzERABERCBBCZgiqJp6GJdlqJJEEOcXqcgAiIgAiJQDwEJIj0eIiACIiACIhDHBCCMxqL5jF3NblAkTYMY2hTH3VLTRUAERCBqBCSIooZaFYmACIiACIiACIiACIiACHiNgASR10ZE7REBERABERABERABERABEYgaAQmiqKFWRSIgAiIgAiIgAiIgAiIgAl4jIEHktRFRe0RABERABERABERABERABKJGQIIoaqhVkQiIgAiIgAiIgAiIgAiIgNcISBB5bUTUHhEQAREQAREQAREQAREQgagRkCCKGmpVJAIiIAIiIAIiIAIiIAIi4DUCEkReGxG1RwREQAREQAREQAREQAREIGoEJIiihloViYAIiIAIiIAIiIAIiIAIeI2ABJHXRkTtEQEREAERiAsCVVVVWbt27bqkffv2r3q9wTt27HgHbXymQ4cO0wJpK/o1rKKi4pmOHTsOCCQ909jzBFtfoHUonQiIgAi4QUCCyA2qKlMEREAERCDhCUAADK2srLwLIuN79s5CKKWmpKRUeAlAsAJFgshLo6e2iIAIuE1AgshtwipfBERABEQgrgls3759IATOJAidMnSkBY6nZGZmvlBSUvIhjtvi+v8aNGgwBeJoEs53IM3Wxo0bP1RUVPQCznNwPwOfy2BJunnnzp3P47gAx5MhUk5D2sWIuRBVX+HeOJSRC6vMODswpPsFzq9BTEFZy7Ozs+86fPjwmrS0tNy2bdvuZlqkmYpyp7Zr1+4VlPMU0uXickO2FWVPsgsi9Gck7j2Ie+xPNj4fQXvestdJQYS2PIdr81FWD3y2QX03o74FyD8nNTX1SdT1pln3cnzmg0GaZVWy14fj8bh/Puq4FHWVxvXDoMaLgAgkJAEJooQcVnVKBERABEQgUgTwQv93vMh/hhf6pyluIDhuwfET+KRIGUsL0Z49ewYcO3bsk/T09JNbt269Zvfu3f0hDgbj3t9N0bAYguEe5G+FeBGu/wjl3ot7Q1D2HJT3F1PUPIfjmVbbTdH0L1wbQDHBtuDef1HGhRRfKOcPhYWFzYuLi1cgTXe06ee43w/X8/fu3ZtdXl4+A+LlKrRlCq4/gzTvIM1KtHMU2rkD7WyLe0vRth4QOEesek1BNB/X++P6ctT7A9wbj3KHBiOIKAghrK5FvLhz585HIzUmKkcEREAEIklAgiiSNFWWCIiACIhAwhGAGDgXAoSi6G3EuRAIM/BZguvXOgTRNAiGrqYAovChFaYdPstx7XTEOxs2bDgTlqWlSNeNwgL378b1+yBUrkB5m3G9B8u2CaLxyN8fVqMb7GAhdnpC7LyNfCdB4NyENCcizV2WpQjXX7Sntyw2EEcbIdwWoI5PrPvI2xHC51LkWekQRP9Ge07ktX379nUsLS1dizoaBSGIaL061ym2Eu4BUYdEQATinoAEUdwPoTogAiIgAiLgNgFYgJrAknIGxMMlqGsUxMOpECJX2AURBMrLEAy9TUH0LC06SMfpbpzSNg95/4r7L/MY089+gfRP43w4zj+DULkFQmUCzi91CJnbcD6AFh9nH5FvJsTG47C+PIj8+ZjOth7XpqHeaZySV5sgQvr16Mc7qKdjfczMNUQvIllPpoMA64D2rkU7GkMQzUZ9k6wpczj/CnVeW8uUOQN9Tse9N5HvCbfHSOWLgAiIQKgEJIhCJad8IiACIiACSUEAL/z3ZGVl/btly5bb6DABQmhHRkbGqWVlZWcAwDV42b+QU+bsggh5pkMgvA5hMoVrkJBuNs7voOUGomUCzoegrPW06uD+PyAamuHaLJT1N4eQGYTz1yCgTmnTpk0R8nLa3gcUVmjH+ThmWcXIdz7z4dovcW0ozq+gFzyknwvxwilrT+M2p8zNRJqNOL4KaT7ctm1bS9T9EI5vwWeVVbc5Ze4j5O1FoYU8V6KMX6DeUWjvK0j3Lo7/YVqONiDvyNrWEOHax8hHa9S1qOOjpHhg1EkREIG4IyBBFHdDpgaLgAiIgAhEkwDEwAUQFw9QeOAzEy/5MyEsHoYIOgkiqADXP8OanN/YBRHy5CEtnRvspEMFxPUQBuORdyyOU3H8BT4vpEAxp95NQRmdua7H2Tfcvx3l/AjpK3FvOfL8hA4RcC2F0+wgWsZxGh/zbd26tSHqeAr3+5vWGTpV+GMtThUeMx0cNMbn/6HM1+z1mo4X/ox7C3G9C2J7xJtQ1qe2e1/i2j7E05HuVsQGdThV4HTBf6GdQywnENEcP9UlAiIgAv4ISBD5I6T7IiACIiACIuBBAnCIMBzT7Li3EB0uVFt3PNhUNUkEREAEPE1AgsjTw6PGiYAIiIAIiMDxBGCl+Q9E0ImI+XZnCGIlAiIgAiIQPAEJouCZKYcIiIAIiIAIiIAIiIAIiECCEJAgSpCBVDdEQAREQAREQAREQAREQASCJyBBFDwz5RABERABERABERABERABEUgQAhJECTKQ6kZkCEycODEfJb2AeCuOn4pMqSpFBERABERABAwjVt8xqHcT+DfBZyt/44A0FyENvRY+iOOJ/tLrvggkAgEJokQYRfUhJAK///3vW2IfkVuR+Y/4n3+IhTz44INj4Kr2TixU/ssDDzzgc2OrIAIiIAIiIAKRIBBDQTQF7c9C/Vf564cEkT9Cup+IBCSIEnFU1aeACED8XArxMw2JO+MLYFtAmZRIBERABERABEIkECtBFExzJYiCoaW0iUJAgihRRlL9CJoA/un/Dpl+JUEUNDplEAEREAERCIFAuIII+dPgZj3lpptuKg+h+oCySBAFhEmJEoyABFGCDai6ExgB/MMvRMpmjtSdcX4OYo01REj7d1z7MYUT4s8Rr0NsibgOU+vux9S6qbA23Qpr0y24xh3dtyL+ybkGCectcP3XiGMROyEeRfwcZUxCGdMDa7lSiYAIiIAIxCsBmyAahz7sQ5yA2AexGPHdtLS0X953333brf4h/WYcH05NTb28oqLi3zjuj3g6ri+kOML3x3h89/wA17ohZiBuwrX/ZGdn//GOO+7gd4wv1LaG6PHHH2985MgR/jB4JSK/nzYi71Moj3VqDVG8PmRqd0gEJIhCwqZM8U4AAuZC/NP/DfoxBF8AN+J4P47fQbwa0SmI/oJrFEJvIm5t0KDBK5WVlRRHkxCzEf+M2A/x/5lc/oDPAYgX4kvobV575JFHmpWUlCzCIQXTM4hLzS+gfHzyC2480v4p3rmq/SIgAiIgAnUTsAkiCo4hiH/Dd9ABfAeNwfH5iF/xOwHpylgKPtfiIxWRImkH4hcQTf+EaNqKe5Nxzh/o3kUZ/H6qRDln4PMKxDdx/2KrJbUJIlx7HfcvQ5yL+CpiDmK+WRd/HJRTBT3MSUNAgihphloddRLAlwHXD12KWL2GqLbpDKalh7/mTcXxd21fMNaUO35Rdbe+wEzHDO/i2jO49jPzS+3/8Hkn4hhcm2MrIwvHnyN2ycrK6jhhwoSDGikREAEREIHEJGD7jjkKq0/f+++/fyN7CiGTgu+O/+KQ3zHXIN1L5nfHCnz2RHwW1zgLwRdwzO+OqYjHMMPgEgiiKts9CpyzUH4PlL/eTL8Jn9Ve5pCfP9otQfw4Nzd39JVXXlnBdI8++mj20aNHef1ERAmixHwM1ataCEgQ6bFIWgIhCKKrkIe/ovkCvryuw5fYZBz+xf5F9dvf/vaEY8eO8ctnGq7z1zd+eVlOGwbVAvyXuEaxdCnSvZG0A6KOi4AIiECCE7AJoldxXMPjG75TLsZ3Cr8D/oF7N5rfHcvx2RczE/r95je/WVYfnldffTV15cqVfK97DPF2xOof4JwWItR1F+piuuNmJyDtRFx/gF9z5nGCj4q6JwKGIUGkpyBpCQQriPCFNAJfSAssYMj/PRy/hl/mfoVf6DhNzhdwnfs87EV8C8cXIXIawtcBgNa0uQAgKYkIiIAIbdBpNwAAIABJREFUxCsBmyC6H8e/tffj4Ycf7oN1QitxbQ7ucQodv098gqhp06aN7GuCzHtd8cmp32cjdkBMc3A5H/k5FZzlbMKH3UL0NM5vxvfXRfj+esueD2k5dfw/iBJE8fqgqd1BE5AgChqZMiQKgWAFEfo9GHk+tfpvCSKc34VjTonzhVoEER0o0NHCOkTue1RrwPSG1db0iURhrH6IgAiIgAh8S8AmiGqzzHCNKR0azEe6Ueb3CQVRD5xzilx1wHkbnHyJSGcIT0LYzIXFhz+8VSJyah3XFtUniLgv0Y8Qz0ZZ79nLtm1JIUGkhzdpCEgQJc1Qq6NOAlEURE1RN9cGbUOddMagIAIiIAIikIQELEEEATMBlplHHSKnN85XIc5GunN5z7QQHSeIIFrugQB6BEmOszQhDx39UBTVJ4jo3Oem2ixEKPuHKPtF3JcgSsJnNFm7LEGUrCOvfvOLJlinCiFZiMwvtS347IjYDfXyuDrgvAUWtR60FrVqaERABERABBKTgM1CNBnH1zu+Cy7COb3P2R3y1GUhehbpfoqp3HmYyv2BoxzfNLv6BBFEz70QPb+HILoNwoweU+3fSY/jhGtbJYgS8zFUr2ohIEGkxyJpCeDLiB59LsdUtZ6YqkbXphRJ+fhwut1+CtfoZS4cQWR9wTyFOqqnzeGY+0YUIHbEHPHezjniSTs46rgIiIAIJCAB23cMp7fl4nyX1U0cv4LjKyFSvgeR8j/zO6kuQTQR9+n44Hrkm2yVAaFzJ4QONxznVLrLzB/++N22CefVa4geeuih4dg+4mNc+wQbvY6yNnrlD3S4Rs927RAliBLwGVSXaicgQaQnI2kJ4B8/Pezchcj9G/gLG737jECMuCCy7UPUC+XzS48LXelsgXO4B+IL8G58AVI0KYiACIiACCQoAQiW6yFYnje/A2jF4dQ1iiLuQURHPUswY2CwNWOgrilzuH4y0nI/u734/qBzhiKUy32H+uD8MdMDKvcn+is3/nYKIuLFNZ97bkQ6C+KeRPyB7gbEzxC5WetDSEPRpSACCU9Agijhh1gdrIsA/tHTK89riKci7kTkbt+cwx1xQWR++fCXN/5yNxaRa4kOIy7HF9afrV8DNVoiIAIiIAKJSwDfOzejd/Tw9n3EBoj3IPKHsiOI3Mj7TqTZYxGoSxCZ3ymX4PNBMz/Xqb6ZkZExoaysjGXxB77RiItRxul1CCL+KMd1TPxO4vFGfh8hLoT1iA6EHkW+CYk7GuqZCHxLQIJIT4MIiIAIiIAIiIAIiIAIiEDSEpAgStqhV8dFQAREQAREQAREQAREQAQkiPQMiIAIiIAIiIAIiIAIiIAIJC0BCaKkHXp1XAREQAREQAREQAREQAREQIJIz4AIiIAIiIAIiIAIiIAIiEDSEpAg8vjQ9+3bNx8eX/I93kw1TwQ8S4DuZ1esWDHZsw1Uw0RABERABERABGJKQIIopvj9V37yySdPRCrtA+AflVKIQF0EHly+fDn/jhREQAREQAREQARE4DgCEkQefygkiDw+QGpePBCQIIqHUVIbRUAEREAERCBGBCSIYgQ+0GoliAIlpXQiUCcBCSI9HCIgAiIgAiIgAnUSkCDy+MMhQeTxAVLz4oGABFE8jJLaKAIiIAIiIAIxIiBBFCPwgVYrQRQoKaUTAVmI9AyIgAiIgAiIgAgET0CCKHhmUc0hQRRV3KosMQnIQpSY46peiYAIiIAIiEBECEgQRQSje4VIELnHViUnDQEJoqQZanVUBERABERABIInIEEUPLOo5pAgiipuVZaYBCSIEnNc1SsREAEREAERiAgBCaKIYHSvEAki99iq5KQhIEGUNEOtjoqACIiACIhA8AQkiIJnFtUcEkRRxa3KEpOABFFijqt6JQIiAAJVVVUNUlJSKgVDBEQgdAISRKGzi0pOCaKoYFYliU1Agiixx1e9E4GkJgBBlAZBdCypIajzIhAmAQmiMAG6nV2CyG3CKj8JCEgQJcEgq4siIAIiIAIiECoBCaJQyUUpnwRRlECrmkQmIEGUyKOrvomACIiACIhAmAQkiMIE6HZ2CSK3Cav8JCAgQZQEg6wuioAIiIAIiECoBCSIQiUXpXwSRFECrWoSmYAEUSKPrvomAiIgAiIgAmESkCAKE6Db2SWI3Cas8pOAgARREgyyuigCIiACIiACoRKQIAqVXJTySRBFCbSqSWQCEkSJPLrqmwiIgAiIgAiESUCCKEyAbmeXIHKbsMpPAgISREkwyOqiCIiACIiACIRKQIIoVHJRyidBFCXQqiaRCUgQJfLoqm8iIAIiIAIiECYBCaIwAbqdXYLIbcIqPwkISBAlwSCriyIgAiIgAiIQKgEJolDJRSmfBFGUQKuaRCYgQZTIo6u+iYAIiIAIiECYBCSIwgTodnYJIrcJq/wkICBBlASDrC6KgAiIgAiIQKgEJIhCJRelfBJEUQKtahKZgARRIo+u+iYC0SGg96XwOFeFl125RcBdAvoDd5dv2KVLEIWNUAWIgASRngEREIGQCEycOLHBjh07UtesWZNaWlqqd6YQKGZmZlb17NmzokOHDhXgWRlCEcoiAq4T0B+364jDq0CCKDx+yi0CICBBpMdABESgXgJVVVUp3bp1y0SiLLzAN0LMbNiwYRpiOQ5LO3XqVHr06FFZOUJ4jsAwZdu2bZkQlJlgmI54DMcMxSiuZOPGjaUpKSliGwJbZYkcAQmiyLF0pSQJIlewRqTQigYVRklWia+srJIsI7UyNSLlqpCIE5AgijhSFSgC8U+AImjMmDFNKysrW2VkZLRBjxrhM71x48ZFTZo0+bpNmzaFSCOLRgSHGsKnwZ49e3KKioqaHzlypElZWVk5ii/G554GDRrsmz179iGJowgCV1EBE5AgChhVbBJKEMWGe221HmpyyDjc9LDBz4rUilobllqRajQtampkH8r2fSp4goAEkSeGQY0QgdgToAi64YYbWkEEdUlNTe0KAdQsPT2dBqGvc3JydkAE7crKyuJLuoLLBEpKStIhjtoVFhZ2gLWoeXl5eSmE0cGKiopNEEdbnn/++X0SRy4PgoqvJiBB5PGHQYIotgNEK9CeVnuMwpzCOkVQXS2kOMopzDHa7Gsj61Fsh1GCKLb8VbsIxJzAY4891g4v3H0ggk5OS0trhZgJMbS/WbNm6zEdbiMsQt+Y+xViQgAWoyxMq+uGzxMxpa7lsWPHShH3QRwth2Bddffdd++KScNUadIQkCDy+FBLEMVmgCiE9rfY74t1WYMCbRmFUcsDLX3CSCEmBCSIYoJdlYpAbAn873//a4+X6kGwMgyFxaETIkXQXliCVnTv3n0lxFBRbFuo2msjcPDgwSYbNmzIPXToUF9YkVrDmleKuA3WvUUQsp9efvnlO0VOBCJNQIIo0kQjXJ4EUYSBBlAcxdDGEzZWrw8KIEtASbjOqNvmbrIWBUQrookkiCKKU4WJgHcJLFy4sC0sCnlo4VmIPSCG0vESvRtT4j5v1arVZy1a4FcuhbghcODAgZb79u07DVPqToW4bQtRxOmM6xDfg8WvYNiwYbvjpjNqqKcJSBB5engMQ4IougNEJwkbu2wM2ypUV6tpLeq2pZvPCYNC1AhIEEUNtSoSgegT2LlzZ2us+7kANV+IOBCRHm52YnrcfMSPGjVqtD36rVKNkSZQXFzcEVPoToe1aCSEUTuUz8W8SxDfgiXp7fbt2++NdJ0qL3kISBB5fKwliKI3QG6LIasnEkXRG1OzJgmiqCNXhSLgLgG8EDdHDRchjkUcjpiGuAfxQ8QCRFoRFBKXQA90LQ/xdETORz+GuABxGuKbsAx+nbhdV8/cICBB5AbVCJYpQRRBmPUUxWly67uvN8rSy6JSYUZ5hnHihhM1fS4qtLUPUXQwqxYRcJcARFAT1HA+IkXQGYgZiHzx/QixAHEVovazcXcYvFY632NzzedhFD5zEDmt7gNTHM2EONJaMa+NmgfbI0HkwUGxN0mCKDoDtK7buoivGfLX8sZHGvumzym4TkAWItcRqwIRcIcARBDnF49BvBTxHMSGiHzB/dgUQV/iU3sFuYM/3kptgAb3N8XRCHxSQB9FnIM4HXE2xJG8CcbbqEapvRJEUQIdajUSRKGSCzwfXWpva78t8AwRTNlpZyefa24FVwlIELmKV4WLQGQJQASlo8Q8RIogWoT4YssX2YWI/OX/M0ROkVIQgboIcArlaeZzNAyfmYgU0jMRKY4KII6035Sen2oCEkQefxgkiNwfoDU91kRtqpyzN5w613NdT/c7mdw1SBAl9/ir93FAACKIv+6PNEUQ1wZxjRBfWBfz5dX8LI2DrqiJ3iNAMTQEkdMsByNScHOq5ZumOJoPcSQro/fGLaotkiCKKu7gK5MgCp5ZMDm46eqe1lyHG7vQfnd73z5FCq4RkCByDa0KFoHQCUAE8R1kECItQYxcHG95DqMliNPiOOVJQQQiRYBTLim8KY4GINIjIV8CaDVi/BTiSOvQIkU7jsqRIPL4YEkQuTtAsVg75OwRXXD32EiHOQouEZAgcgmsihWBUAhACJ2CfBRAdI7Q2SyDa4Eogugg4XAo5SqPCARJIBvp6YghD5HPJMNWRHqqmw5htCzI8pQ8jglIEHl88CSI3Bug8vRyY3WP1e5VEETJvdb1MtLLacVXcIGABJELUFWkCARDACLoRKS/DJEiiL8A8f2D/4ApggoQC4MpT2lFIMIEWqC80Yi0HPVG5BQ6um6nOJoKcbQ+wvWpOI8RkCDy2IA4myNB5N4A7ceG5Tvb7nSvgiBK1rS5IGAFn1SCKHhmyiECYROACOqEQiiAGE9G5DqhDYgUQYy7w65EBYhA5Am0NYURxVF3UxwtN8XRNIij2Hhhinw/VaKNgASRxx8HCSL3BmjjCRuNI42OuFdBECU3LoYL7s1ywR0EsmCSShAFQ0tpRSAMAhBBXAd0iSmCuD6IIogvkJYlSC+TYfBV1qgToKjPM2NHUxx9aoqjNyCOYrsIOeo4ErdCCSKPj60EkXsDJEHkHluPlSxB5LEBUXMSiwBEED3CXWiKIO7/QpfHfFGch1iAqOlGiTXkydobTvWk1YhT6yj86fqdjj84re4tiCN6rlOIUwISRB4fOAki9wYolu62nb2S+233xhklSxC5ileFJyMBiKDG6Df3COJ0OL4k0rXxAcQPEWkNWpWMXNTnpCGQaz73dMrA9Ud0Cc/nnuJoJsSRN6afJM1whN9RCaLwGbpaggSRe3iX9+GUYO+Ek1dxir2CCwQkiFyAqiKTjwBEUBZ6fQ4iPcSNQaQLY252Od98GaSnOO3nknyPRjL3mFNC+yHmIdI6yk2E6Sp+NiLdeM+BOOKmwgoeJyBB5PEBkiByb4AkiNxj67GSJYg8NiBqTvwQgAii+0tagGgJokXIeuFbiOMCxCWInDqkIALJToBTRU81/16G45M/IPAHg5mItBx9AHHEzYYVPEhAgsiDg2JvkgSRewOkNUTusfVYyRJEHhsQNcfbBCCC+Ks3f+2mCOLaIE4J4ovcJ3ypMz/LvN0LtU4EYkqAU0gHI+aZn/xhgVNK30KkOPoY4kjW1JgOUc3KJYg8NBi1NUWCyL0BkiByj63HSpYg8tiAqDneJAAhRK9wFEH0EkfXwxWIn5siaAE+ORVIQQREIDgCnFrKHxhoaR2ImIpIl/NvUBxBGNFrnUKMCUgQxXgA/FUvQeSPUOj3t7XfZhTmeGMvwJzCHKPTTnr3VHCBgASRC1BVZGIQgAji4kWKIK4L6oJYhbgMsQCRa4MOJ0ZP1QsR8ASBbLRiJGIeItceMWxB5HojiiNvLW72BLLoNEKCKDqcQ65FgihkdH4zHmpyyNjSmf+HYh+6bO1iNC1qGvuGJGYLJIgSc1zVqxAJQASdiKwUQZch0pUw3wW+QrQ2TPXGL0Uh9k/ZRCBOCOSgnbQaMfZG5I8R6xCnmuJI7uqjOJASRFGEHUpVEkShUAs8z6peq4yKBpwVEruQWplq9FndJ3YNSPyaJYgSf4zVQz8EIIJogqYViELoFESuE+ILlyWCtMGkniIRiB0B7muUZ4qj7vjk+iJaarneaDosR9rQ2OWxkSByGXC4xUsQhUuw/vxbOm0xDmUfcrcSP6Vrupzr+CWIXEesCrxIACKIL1kXmyKIC7wpgrYicsPU9xG3e7HdapMIJDkB/nhhiSMeUxwtNsXRDIgj/XjhwgMiQeQC1EgWKUEUSZrHl1WSVWKs60YLdexCj409jKwSeudUcImABJFLYFWs9whABHEaDj3D0RLEtQp0BcwF3JYlaIP3Wq0WiYAI1EGA01s5pW40Ih2d0MU91/bRcvQWxJGmt0bo0ZEgihBIt4qRIHKL7LflxtK5gqxD7o8vapAgigpmVRIrAhBBjVH3eYhcE8SXJ7r83Y/4EWIBItcHKYiACMQ3Ac6t59/36Yh0hV+KyB86uOboHYijI/Hdvdi2XoIotvz91i5B5BdR2AnK08uN1T1Wh11OKAX0WtfLSC/n9gQKLhKQIHIRroqODQGIIJqVz0akJWgMIl370iMcfz0uQKS3Ku1zEpvhUa0i4CYBTn3lOkCKo1GI1mbJs3FMy9FciKMSNxuQiGVLEHl8VCWIojNAdL9NS1E0A91s00Kk4DoBCSLXEauCaBCACOKvJ5w6QxF0PiJd+HJvIO4RRBG0FJFTahREQASSgwCnxHJvI4qj4YjWDyMzcUxxNA/iiJsqK/ghIEHk8UdEgih6A7Sz7U5jfwvOMnE/tDzQ0mi/u737FakGEpAg0nMQtwQggvhrMF90KIIuQuRUmTLETxA5XYaLrXmuIAIikNwEMtD9IYgUR/zkDygHEN9EpDhaAHEkq3Edz4gEkcf/eCSIojtA0VhPpHVD0R1TCaKo81aFESAAITQIxdBN9iWI7RC5P8BniAWICxE1JSYCnFWECCQoAU6p5Q8peYinIqYi7kJ8A5FuvD9N0H6H3C0JopDRRSejBFF0ONtr2dNqj7GntTteLdvsbWO02UdPuApRJCALURRhq6rQCUAEnYzc1l5BXXDMjRq/RKQliA4SikIvXTlFQASSlACn1tLjZB4i1x7x3X8zhREjxBHXGyZ9kCDy+CMgQRSbAeKaIk6hi9Smrdx8lVPktGYoJuMpQRQT7Ko0EAIQQXSry+lwjD3NPKtMEUQhdDCQcpRGBERABAIgwIXLnFLH2BuRP7qsReSUumkQR9ysOSmDBJHHh12CKHYDRDHENUX7W+4PWRhRCLXc39LgmiEeK8SEgARRTLCr0roIQAR1tIkg/mLLdULcEI0CiJumumOi1pCIgAiIwLcEOF2FTlryEPnDDNcXLbOJo6TauFmCyON/GhJEsR8guuX+utnXxqHsQwY3cg0kcKPVpoebGs0PNpdb7UCAuZtGgshdvio9AAIQQa2QjOuBuFcQ1wfxF5ItpgiiEEqql48AkCmJCIhA9AjwRxoKI1qOOiNyzSLXGXGPozdgOdoXvabEpiYJothwD7hWCaKAUUUlIcURhRGtRxWpFdUCiQIotSLVZwWiENLeQlEZjkArkSAKlJTSRZQARBCnp1xgiiDO4aeLXC5spgBi3BjRClWYCIiACIRPoLspjGg9okMXuvLn/mYUR29DHBWGX4X3SpAg8t6Y1GiRBJHHByjOm9eyZUujS5cuRqtWrYzGjRsb+EdnlJSUGIcOHTK2bt1qbN++3aio4A9FcR0kiOJ6+OKr8RBBjdHi75giKA+fmYj05/8hYgFibHaBji+Maq0IiIA3CHCdEf+PcQPYloil5v8xiqNZeGc44o1mht8KCaLwGbpaggSRq3g9W3iDBg2M3Nxco1evXsbXX39tvPfee3W2tUmTJgaeE6N169ZGamqqUVRUZKxbt87YtGlTnXkaNmxonHbaaUbbtm2NPXv2GLt37/blq6ysNBo1amRQKHXs2NEnjhYuXGgUFsb1D0ISRJ590hOjYRBBdHF7FiIdI5yLaG2OSBFESxC9OHHxsoIIiIAIxCMBrnOkF0xOqaM4sjaFfhfHdMjwHsRRYGsKPNp7CSKPDozVLAkijw+QC83Lzs42hgwZYlDopKWl1SuImjZtapx55pkGXsiMzZs3G+Xl5UaHDh2MnJwc48svvzTWrFlzXAubNWtmnH766T6x88knn/isQbWFzMxMXzsojubOnWscPnzYhd5GpUgJoqhgTq5K8DfH6W98OaCbbE6L4wtCMeICRIqgJYhxb15NrlFVb0VABAIgwP99AxDzELnXkfUD0Ns4pivvDyCOOM0uroIEkceHS4LI4wMU4eZRAF100UU+8UHLzLnnnmscPHiwTgtRXl6eQYFDC5IlWGhdOuuss3wiidf5aQWKnHPOOcdn8Vm0aJFx7Fj9/7M4hY510PI0Z86cCPc2asVJEEUNdWJXhL8l/krKFwCKoIsRWyCWIS5CLEDkIuTyxKag3omACIhANYEMHNFJTB7iEESeH0CcgUhxtADvEfRe5/kgQeTxIZIg8vgARbh56enpRu/evY0VK1b4pq9ddtlldQoiWoEobr766itj+fLA9lUbNmyY0aJFC+Pdd9/1iSGKpx49ehjdunUzOI2O0+ZWrlzpE1EjR4403n//fZ/VicJs3rx5vul19tCpUydffraF4unIkSPGli1bjNWrV9cQYhHGFGxxEkTBElP6GgTw93AaLlAEMXKRMS0/nyEWIC5EjOupIhpuERABEYgAAU4dHoaYh8j/mfSkSScy1gaw/J/p2SBB5Nmh+aZhEkQeHyCXm1efIOrZs6fRr18/n2jZv3+/T5BQUJWV8Qfr4wMtSWPGjDE++ugjY9euXT4xNHz4cN86orVr1/rK4BQ8lrt3716jffv2xvTp031OFWhx4lqmJUs4C+ibwPVNp5xyim/9EZ0vUMCxLIoklj9/Pp3SeCJIEHliGOKrERBBfdFiCiC6ye6CSFPrF4icDseHuyi+eqTWioAIiEDUCDRBTVxrxGnF/RCpN7jNAJ0xTMf7yoqotSTAiiSIAgQVq2QSRLEi74166xNEgwYNMrp27WrMmjXL6NOnj0+IUORQEG3cuNFnNbJPlxswYIDRpk0bn3WIwRI0CxYs8AkaK7BMlk0BxLVDDHTAQAsSxRQDj88//3xj586dBvPbQ//+/Y2TTjrJJ4h43wNBgsgDgxAPTcDfSze0kwKIzhF6mW1eic8CRDpIOBgP/VAbRUAERMBDBJqhLRRGjH3MdtHbJp0xTIU48sT2AxJEHnpiamuKBJHHB8jl5tUniDiljVYcrgfi+qEdO3b41vqccMIJPo9zdJvNdUJWOO+883zCZ9myZT7hxLVKBw4cqBY5Vjq636bY2bBhg/H555/7Lvft29do165dtUDiNDkKrMWLF/usQfZAS9To0aN9nu6WLl3qMqGAipcgCghTciaCCOKGhJYl6BQcc53QWkRrr6CE35AwOUdevRYBEYgBAW5QnWeKox745PqiZRRGiLQcxWyDagmiGDwNwVQpQRQMrcRLW58gGjVqlE+k0Br02Wc1p+aeffbZRvPmzY3Zs2f71iDRWcOll17q8ypHoUTBdMYZZ/gEDb3T2YO1Nsl+j+KHQueDD/iOaBinnnqq0b07926rO1Cgffzxx14YFAkiL4yCh9oAEcQv5UsQaQkajMi57vxD4AP+PmJNle+htqspIiACIpAgBPhjlGU54rRkrs1cjEjL0RsQR1H9MUqCyONPlQSRxwfI5ebVJ4i4/od7BdXm7ODEE080Bg4c6LPQ0FJjWX0KCgqMffv2+ZwocBocp8Rxapw9WNYfTq2zXHJTfJWWlvoEFMPgwYN9lii69qbgqi1w6p6zbJdx1VW8BFGMwHupWoigHLTnfEROiRuJmI7IOZ2WCOL8dgUREAEREIHoE+iKKvMQRyO2R6S3Tq7VpOVoJsSR65shShBFf9CDqlGCKChcCZe4PkFEhwZcB0SrDZ0g2APXE9GjHNcR0QudJYgsBwy1iR4rPz3X0bnCtGnTfI4SrOl1FD/WZq+Whci5/sijAyBB5NGBcbtZEEGNUcd3EGkJOhMxE5G/Os5DpBA6fqMutxul8kVABERABOojwPWbtBxRHLVELEWk5Z6Wo1kQR0fcwCdB5AbVCJYpQRRBmHFYVH2CiBuwjhgxwrcmiG6u7cFymGBNe+PaIpZlCRgrL6e0cWqbFegMgeuFaN15+23usWb4psbhOTRmzpzpc8HNYFmgWC/rtwcKKEZ/exxFcTgkiKIIO9ZVQQRR9JyNyHVBFEPcNJC7D9MjSAEivRt9uzlXrBus+kVABERABGojQI1yMiLF0emI3Pz6KOIsRLryngtxRLEUkSBBFBGM7hUiQeQe23gouT5BRJFD5wcMnPp29Cj/T2AeEFxv0712VlaWT9SUlHyzRQqdKNDCQ6sR1xTRyQLzcANYihdOo+vcubNvryEe03sd1yFxehz3ReLUOytYXuYokJjO7uqbHu+4lxItV3Ta4IEgQeSBQXCzCRBB3DmdvyZSBF2A2BSxGJGL2AoQ6S6b89MVREAEREAE4o8A13kORKQ44ubYjRD5Qxd/uaU4mgdxVP9O8376LEHk8YdCgsjjAxTh5tHZAffysQL3BKLYsKaq8fqaNWuqBQgtPVxLxPU9dJZAN9tcV8QpctZ0OassrimiEwZaehh4PGTIECMjgxtLYxU5vMXRotSoUSOfwwWKJgolbtTKOp3BskLRw9369et9aenW2xJVH35IL8WeCBJEnhiGyDYCzzq9wXETQIogOkhogchNuLhRKqfDfYr4jUlTQQREQAREIFEIcP3nIMQ8xKGIfInhr69vIFIcLYQ4ove6oIIEUVC4op9Ygij6zGNZoyUy6msDBc2RI99OoaWIolWmRQu+Dxo+F9zcaHXLlpprxOkljt7nKJQsgcOpbU2aNPEJLMuSxDIohmgFYj1cR1RX4FpQOU1uAAAgAElEQVQlrkeiZzqG4uJiX70sv758UWYsQRRl4G5WByF0KsqnCGLk4lv+Kkg3ixRBFEPfmEQVREAEREAEEp1AFjrIH8byEPndwNkCdJZDYUQ33t/sHRJAkCAKAFIsk0gQxZJ+4tWdm5vrm862ZMkSn7vu+gItVdnZ2TWmysUpEQmiOB04q9kQQbk4tvYKOgHHVOmcBleASE9EnB6nIAIiIAIikLwEmqDr9CDKaXX9EalxuJ2CtccRN9muM0gQefzBkSDy+ADFYfPoIIGWKHqm41Q8usamdYhWIVqLWrZsadDyQ6sPrT3cuyjOgwRRHA4gRFA3NJve4egmm16HGOgQgZYgeonj/HEFERABERABEXASaIYLdMSQh8gf1BjofYriaBosR8f9IixB5PGHSILI4wMUp82j6OFUN65BonMGeygqKvKtJ6JYKix03fV/NAhKEEWDcgTqgAjiRn20BFEI9UPkOiEuYLNEUFQ36otAl1SECIiACIhAbAlwI25rA9iTcMwZBl9SGCFyWt12Nk+CKLaD5Ld2CSK/iJQgDAL4R+DzRsdYUVHhsxTZPcaFUbSXskoQeWk0amkLhNB1uHw54hBTBG0yRVABPnd5vPlqngiIgAiIQHwQ6IBm5iHSK6k1/ZrTYP4nQeTxAZQg8vgAqXnxQECCyOOjBEHERbB7ECmAGGt6BPF4+9U8ERABERCBuCNAQcQNuymO2kgQeXz8JIg8PkBqXjwQkCDy+CiZgojT4h73eFPVPBEQAREQgcQicBe6c4YEkccHVYLI4wOk5sUDAQkij4+SBJHHB0jNEwEREIHEJSBBFA9jK0EUD6OkNnqcgASRxwdIgsjjA6TmiYAIiEDiEpAgioexlSCKh1FSGz1OQILI4wMkQeTxAVLzREAERCBxCUgQxcPYShDFwyipjR4nIEHk8QGSIPL4AKl5IiACIpC4BCSI4mFsJYjiYZTURo8TkCDy+ABJEHl8gNQ8ERABEUhcAhJE8TC2EkTxMEpqo8cJSBB5fIAkiDw+QGqeCIiACCQuAQmieBhbCaJ4GCW10eMEJIg8PkASRB4fIDVPBERABBKXgARRPIytBFE8jJLa6HECEkQeHyAJIo8PkJqXrAT+gI4PNDtfgM9HkhWEo99v4TzVvPZnfPI8nsP30fjrzA58jU+ehxvcKDPcNtWVX4LILbKRLFeCKJI0VVaSEpAg8vjASxB5fIDUvGQlIEFU+8hLEPn/i5Ag8s9IKYIhIEEUDC2lFYFaCUgQefzB8JAgOgeo2iEuR1zqcWxqngi4TUCCSIIo1GdMgihUcspXOwEJIj0ZIhA2AQmisBG6W4BHBFFj9PLfiFmIryI+726vVboIeJ6ABJEEUagPqQRRqOSUT4JIz4AIuERAgsglsJEq1iOC6EL051azTxJEkRpclRPPBCSI/AuiJ5HknXgeZLTdDfHiRpluYdYaIrfIRrJcWYgiSVNlJSkBCSKPD3wAgmgQukDB0g2xOeJRxH2IXyG+h7gyjC5ycfTFiD9EpJWotnBeGOVbWa11BwtxYSJie8QbEAcgNkL8ntmvUKpqiEyjEU83GTXD5zHE3YifIr6GWBhEwS8ibRsz/T/M/FZ2+4sOrzHtS7ay2Y8bzfOt+PxJEPVGK+lQVHQuYk/EHMRyxG2IixBnIfLZCiaMQOLf2DI8iuP3HQWchfO7bdcm4DicaZmR7kNt/XVTEPVAhZcinoLYArEUcT0ixUVBMPBjkNa+huhx83nh/48TESsQOeV2MuKmENpGC/U0Wz6OwQeOct7AeYZ5LRJOHdwQL/WV2QBt59/LMLMPRfi8E3FzCLwikUWCKBIU3S5Dgshtwio/CQhIEHl8kP0IIr5c8yW7rrAFN34aRhevQN4f+8kfSUFEYcIXY75IUbgwULxcFEYf+HLBl/K6wgHcuANxV4B13IZ0Vp8pqO6z5fs9jk+1nX+G41/bzn+LYwpYhumITwdYZzSSpZgcxtRT2S9xjy+0wYQ0JOZ0S2s8P8IxOdjDr3BC0cpAwcUX6KpgKjHTutWH2priliA6H5WNQyS32kIBLlJUhsInBKRBZ7ELIgo4Pk+W1zmrsBIc3IO4OsjSk0EQ3QIm1v87/hjB/y9fBMkpkskliCJJ062yJIjcIqtyk4iABJHHB7seQcRf72l94C+KDJsQaQ3KRuQvy7zPF26+eIca+CvlSDPSUmPVs9ZW4P8LtXBbPvtL1B5ctywwTBKuq9tclPFHRFrOliGyfDqHsIQJ6yhADNRt8hlIe6/ZdpZJQcpfvvnS9z9EvrTxhY+fRxApKisR+YJLaxQtVgwUap+Yx174uBKNoFXOCmwzRSKFDK2DOxGvD7GhNyPfWDMv2bCuMvOcXDgN03q+XsfxcyHW42YfnE1yQxD1QiX8e7LE0Docf47IvwcKRutv/VkcTw2RkdvZ7H/LrIvP0Q7zOeL/JitswgGfi2BCoguiqwEj3wbkMRzTyh/LIEEUS/qB1i1BFCgppROBOglIEHn84ahHEPHlaZKt+bfjeJV5zhen0xApkPhSHm6gE4UOZiFurCFyvkRRtHBqDF8I+UIVrFXC2d/BuPAlIqceWcH+S+xhXKRwCSQ0RaJXEGmNYKDFiNMTeyNyzQQDRSinPDHw135Od7KEGa/xl1/WR3HghcAX8P8gWi+stCzSsrXXbByncDVBDHUaG6dL/cXW0Yk45vRIBgpTu8WI48JxDza43Qdne9wQRA+gkuFmRXzm+TJqWYL4PP3MvMe/jx8FCyhK6e1/y3ZLEMeHz5TVPzaHltlgpvQmoiCyxvJsc7ytYZqMg5ejNGb1VSNB5IFB8NsECSK/iJRABPwRkCDyRyjG9+sRRC3RNE5FsgJ/weealQ8ROc0skiGagmg/Gk4REcy6nlD66ly3wmkqgXJ7CmkpEhisdUTW9EKWwWmKlic+CoEZiD9AtF5iKSy4TsYrgWu17Bayh3E+P8KNIwcKIwauRXrCPLYLU65VstZYBVt9NPpgb1OkBRHXvfwX0Vr/Qj7kZAVa0Gg9s8I1OODfiteCXRBxrRin91mhIw7492KFv+GAVtVAQyIKIv74wB9SyCndBMGphtaPK4GycSudBJFbZCNZrgRRJGmqrCQlIEHk8YH3s4bIvvbC6gnXxNC6QiuF3SISTk+jKYgibYFqi45fgtgfkcecskbrDqM1BYlsmMaaxuWPFaeOXWUmWozP+xEpImiJonWDL/mTETk1rwCRYoORL+0M5Ml+eiV8Bw2hhdEKnLoTaUF6Gcq8yazgID65sJzWv38htjKv85gxlBCNPtjbFWlBREciLwTR8Z8j7YYg0kcrqV0QsT+0ptoDRR+tjQzBrqNLREG0ERw4JdWaJswxpUdPTsP1QpAg8sIo+GuDBJE/QrovAn4JSBD5RRTbBH4EEX9R5LoPeoJzLsLmVAxOweEXbrghmoLIsqiE22bm74NIRwfWup36ygxGENmtEXy5pziyXvSslzxagPIQOQ75iPx1ny90DNY0ukj0MRJlOJ1ncGF/pBftc00bxY71nPJFi4L9T7YO0IHH9hA7FI0+2JsWaUFEr352Fv4w8KXZvpbPX/po3bcLotr+liejIfyhgCFYS4g/QcQfOVi/9UNHPHiZc44LhRD/NoKZSujm2EoQuUk3UmVLEEWKpMpJYgISRB4f/ADcbrMHrRG/i0jvZ/aX/0i5do6mIIrES4w1qpx2wrU9DHz55lQ3WnRo/bA7R+D9YAQRhSgdJFgCh9YVawoYLUEFiPY1H1wrQccODKybFhgvBXtb2S4KPAq9SIeJKNByJ0wByTUm15qV0OPY+DAqjFYfrCZGWhBxjZ59w+N/4rw+CxAdhNAls9eCXRCxD/ZpvWwrfxiwHGjQkv1MEB1wCiLrb80qgmvg+HdphUj8L3Hb7bbVVo6lZTmjMxNaAIuDYONWUgkit8hGslwJokjSVFlJSkCCyOMDH6AgsnpBj2D85XiUrVvX4Zh77oQTOO+f8/8ZIj2ljWXaX6Ii8RLDMvkr8ZvmJ8+d03O4ZohT26wQjCBiHrsLbU4LsqbQcTod13PZnV7w5d9yj06vUfQe5aVAkTLR1qAHcbzAhQbSYyGnFzLQEQWdS9AjIgNfjO17zARbfbT6YLUr0oKIa4coFiwL2t9xzOcm3oL9b5nPEJ8lK3Q1x9k6D9ZbHhlxnyErOL1o0pHM72z3I/G/xG1BxGmjFMJ0MkKLWqbZfq/8n5Agioe/QAmieBgltdHjBCSIPD5A9Qgirrvoi8gNM+3eynjN7go7nGlIFh2+WJxkntAhAN1Oc0oVX1D4hR6oM4K6aLsliFiu5Q3OuT6Fi5i5rsgKwQoiWuSsPZ7W4JhTnuzWH77Y0jUyrUn0Mmc5FPg/HM/x2GNHIc1f8q2XcS70pnCxhDTXt3BK2mTEQ2G03b4nkVUOvfbxGaKliOvfQg3R6oPVvkgLIpZr3zOLFjpuyElHE/ZAiyc5hut5MVTO/vLZ/5YpeCmIuF8X/1ewf3Z397/AOf92ggl2C5PTOYlzz7F4EET2bQXs6+zIxGkBC4ZTpNJKEEWKpJvlSBC5SVdlJwkBCSKPD3Q9gogChV/4FEOcb861F3z5H4rIKXQMfEGndzO+cIYTuCHnObYCuC6G0zn4okxXwNxnJJzghiBie2h16Go2jC+YFEWcOkcPc5aDA6vdwQoiluuc7uP8RZxu0Wkpsgf+4syXIK8F5xhT8FIQUdDRoyFDJNrO58VySW4xWIIDa2+ncLhEqw9soxuCiJ4LObXS8jRHJx90F8/nhWPQCZGL78NxPhEO30Dy2v+WrfRsP6fyWlNMed1yPhJImfY0E3FiTbvk9RVmWRSKzr+1eBNE7A83pbasppxGx6lz/H8bqyBBFCvywdQrQRQMLaUVgVoJSBB5/MEIQBDV1QMuzuUvjHTDHW7gywYtG07HDSyXTh28KojORNvuqaPzBbh+MqLl4SxYQcRiuTFuC1v5Tu9xdJ5AhxdW4JoQvuB4MXD9Al/yLUtgbW2MhCDiSz/XctkDRcC7EYASrT6wqW4IIpbL6a5cc2ats6kNS7wIIoqjC2vpAF/070YMxUseLa20gNvFlVUFhRedyJxqXohHQUSHE5wKaK0FpSWQrML9USvUPy8JolDJRTOfBFE0aauuBCUgQeTxga1HEPGFietgaBHqYr5AUQRx2hEtRpyuFUkvVHzJoLXJ2n9nH465DoRWknAXd7tlIeLocooOX+S7IdKCRksavVuxTq73udJ8BEIRRHxZ4IaKVuCLC3/RtwKtarRaWIFrQrg2xKuBlokLEEcjnoDIl05aAvmSScESqal+f0VZ3U0ItIJwfI5ECEq0+uCWICIGWoH4tz0YkdZeaxw4fe5jcxwi7RY9Qvir1wPyfwM3LabzEk63pHWLU2s5zW0yonMqYDD1d0ViTrHsh8j/g9yP6TNEbi5MQc+pcwzxKIjYbv4NcjqhFaaYfQuGUaTSShBFiqSb5UgQuUlXZScJAQkijw90kE4VPN4bNU8EfATuQ7Qcf3yEYzqoUBABEfAeAQki743J8S2SIIqHUVIbPU5AgsjjAyRB5PEBUvOCJUDnBy8iWt60uKHt/GALUXoREIGoEJAgigrmMCuRIAoToLKLADwALV++fKJAeJeABJF3x0YtC5oA10X8CpFTwRg47YtTn8L1Uhh0Q5RBBEQgIAISRAFhinEiCaIYD4CqTwQCEkQeH0UJIo8PkJoXCAE6tuiKyAXj9o2Due/KjEAKUBoREIGYEJAgign2ICuVIAoSmJKLwPEEJIg8/lRIEHl8gNS8QAjYHRBY6WfjwL5fViDlKI0IiEB0CUgQRZd3aLVJEIXGTblEwEZAgsjjj4MEkccHSM0LhAAtRHSiQC+I9Fj3JuLcQDIqjQiIQEwJSBDFFH+AlUsQBQhKyUSgbgISRB5/OiSIPD5Aap4IiIAIJC4BCaJ4GFsJongYJbXR4wQkiDw+QBJEHh8gNU8EREAEEpeABFE8jK0EUTyMktrocQISRB4fIAkijw+QmicCIiACiUtAgigexlaCKB5GSW30OAEJIo8PEATRODSxGHG72dRSfH7uaHZjnHPXdns4gJPVjmttcd7dcW0rzp27xjMN09rDKpzQTbI9sE7WbQ+f4qTccW2447wE50sc15rg/BTHNe5Av8ZxjZ7KujmubcG5xce6dSIO2jjSrcT5Qce1/jjnbvf2sBgnTlfQzj4cRZqljnzZOD/ZcW0fztc6rrXHeVfHtc043+G41gPnrR3XVuD8UAB9+ARpuGbHCg1wMNSRj8/VF45rTXHe13FtL87XOa51wPkJjmubcL7Tce0knLdyXFuO88OOawNwbvdAx9sLHGlScT4kxD7sQb71jrwdcd7FcY1rnHY5rvXEeUvHtWU4L3JcG4jzLMc1Zx/ScN9yO24lrW0cuF9TrqOs3Tjf4LjWCeedHdeYhmntoRdOWjiufYnzI45rp+Lc2iPKuuXsQzpuDHLkYzkszx5ycNLHcY1sydgeausDx4pjZg+9cdLccY3PL/nZw2k4ybBdqMLxQkca3mc6e+B4clztgfWxXnsItA/8m+Hfjj2QB7nYA/+P8P+JPZAvOVuhEgeLHGk4Thwve+DfFf++7IHjzvG3B/6dbnJc43PEsbAH/i8/luK4qFOPEZAg8tiAqDnxSECCyOOjBkHExej2UJqSksIX9uqANBQTfKG0h/1IRxFjT0cxwZdse9iMdBRF9nRMw7T2sALpvnakY52s2x4WIV0NQVRLH0qQhsLJXifFBMWJPexDuq8c6SgmKHbsYRPS1RB1qJMv4k5Rtxzpaog6pONLrFPULUS6GoKolj4cRZrPHG2jmHAK071IV0OYoiyKCacw3Yh0NUQd0vFF3CnqliFdDVGHdHwpcoq6BUhXLYiQhoJohINbMdLUENdIxxdxpzDdg3Q1hCnSUUw4hekGpKsh6pCOL2JOUfcl0tUQdUjHl9MagghpPnLwpSByCtNA+7Ab5dUQpqiTL39dHUzWI10NUYd0fCF2irovkK6GqEM6vsTWEES19IGCaJijziNIV+MHApTFl2anuN6FdDWEKdLxJdYpTGvrA1/EnaJuKcqrIepQHsVaDUFUSx/4ou4U10VIV+MHApRFMeEU1zuRroYwRTqKUqcwXYd0NYQp0lEgOkXdEqSrIeqQjqK5hiBCmhqb/yIN7zvF9WGkq/EDAdKxPqcwDbQPa1FeDWGK8sjDKeo+R7oaog7pyLeGIEKajx1/Dxwnp7g+hHQ1hCnK4rg7hekOpKshrpGOz5FTXK9Buj0SRI6/WK+dShB5bUTUnjgkIEEUh4OmJouACIiACIhAtAhIEEWLdIj1SBCFCE7ZROBbAhJEehpEQAREQAREQATqJCBB5PGHQ4LI4wOk5sUDAQmieBil/8/eeYDPUdXrf0lISBCkqIAUQXqXCwpYUJQugggWRFSKCGLD+/eKBUUv117Qi3oFE5oKKiqEX+gd6RAFUgkhgISINAkCCWn833fdTTabqbszszO7n/M859k2c8rnzM6c95zv+R7KCAEIQAACEOgRAQRRj8AnzRZBlJQUx0EglACCiIsDAhCAAAQgAAFmiKp6DSCIqtpylLtEBBBEJWoMigIBCEAAAhAoGwFmiMrWIm3lQRCVvIEoXhUIIIiq0EqUEQIQgAAEINAjAgiiHoFPmi2CKCkpjoNAKAEEERcHBCAAAQhAAAKhBBBEJb84EEQlbyCKVwUCCKIqtBJlhAAEIAABCPSIAIKoR+CTZosgSkqK4yDADBHXAAQgAAEIQAAC6QkgiNIzK/QMBFGhuMmsPwkwQ9Sf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQQBBlgjG/RBBE+bEl5YEhgCAamKamohCAAAQgAIH0BBBE6ZkVegaCqFDcZNafBBBE/dmu1AoCEIAABCCQCQEEUSYY80sEQZQfW1IeGAIIooFpaioKAQhAAAIQSE8AQZSeWaFnIIgKxU1m/UkAQdSf7UqtIAABCEAAApkQWGHrrbfeZtiwYa/KJDUSyZzASy+9dMQKK6zw0cwTJkEIDAgB/YfO0X/o7AGpbuWquXjx4iemTJkyuXIFp8AQgAAEINA3BFbYaaedRsydO/cgdRg+plrtqddhfVM7KgIBCEAAAqUjIJG6WIW6Wq9jRo8efdGECRMWlK6QFAgCEIAABAaGwDImczLP2kAPqI9JFB0pAhsMDAUqCgEIQAACRRB4RM+Ys/SMGTNp0qRHisiQPCAAAQhAAAJxBMLWEA3bZptt9tbJFkcH6nVEXEL8DgEIQAACEAggsEAi6GJ9P2by5MlX6tWzQwQIQAACEIBAaQjEOlXYfPPNXzly5MgjVOKjFbcsTckpCAQgAAEIlJnANBVu7Pz588+ePn36k2UuKGWDAAQgAIHBJhAriFrxaNboLRZGmjV6v15XHmx01B4CEIAABNoIvKDZoN9bCGk26CboQAACEIAABKpAIJUgalZoiy22WHX48OGHyTudHTG8vgoVpYwQgAAEIJAbgbvkLW7MokWLzrvvvvv+lVsuJAwBCEAAAhDIgUBHgqi1HFtuueV2K6644jH67nDFNXIoI0lCAAIQgED5CPxTRfr1woULfzlt2rSJ5SseJYIABCAAAQgkI9C1IGpms+mmm66kcIg+e9Zod7hV+S8AACAASURBVJnVZZZ2sqpwFAQgAAEI5ElA5nAvKf3rFce8+OKLf5wxY8aLeeZH2hCAAAQgAIEiCOQiWrbaaqsNZVJ3bGNT0VcXURHygAAEIACBfAjoXv53b24rk7jTp06d+nA+uZAqBCAAAQhAoDcEchFELVUZLkcM79Rnu+/264q9qSa5QgACEIBASgILJYQu1Tl2l+3XRSnP53AIQAACEIBAJQjkLYiWQNhkk03WkkmdPdQdpbhpJehQSAhAAAIDRkAiaIbimTKJG/vAAw88PmDVp7oQgAAEIDCABAoTRK1st9122931+WN66B4icTRqALlTZQhAAAKlIaB78Tzdi/+oAo2ZNGnS9aUpGAWBAAQgAAEIFECgJ4KoWa+NN954tdGjR3/Y4kgP49cVUF+ygAAEIACBBgEJoXssgubOnfurmTNnzgEMBCAAAQhAYBAJ9FQQtQLXrJH3MzpaD+jDJI5ePoiNQZ0hAAEI5E1A99hndY89T/mM1WzQXXnnR/oQgAAEIACBshMojSBqglp//fVHr7baau/XZ88avaXsACkfBCAAgSoQkBC6SeUcM2fOnN/PmjVrbhXKTBkhAAEIQAACRRAonSBqrbQ81G0qUXSsvvuI4lpFACEPCEAAAn1EwE4RzpUYOl2e4mb0Ub2oCgQgAAEIQCAzAqUWRC21XFEmdQfqoe5NX/eRSBqWGQESggAEINBHBHSfXKzqXKH7pB0kXKz3C/uoelQFAhCAAAQgkDmBqgiiJRXffPPN1xsxYsTR+sLuuzfMnAgJQgACEKggAQkhb5h65oIFC8ZOnz790QpWgSJDAAIQgAAEekKgcoKohdIKmjXaU5/tvvsgiaORPSFIphCAAAR6RED3vvm6912k7D0bdLVeX+pRUcgWAhCAAAQgUFkCVRZES6BrrdGa+vBRRW/8uk1lW4OCQwACEEhAQEJosg4bq3iO1gY9neAUDoEABCAAAQhAIIRAXwii1rpttdVWuw4bNsxrjT4gcbQKLQ8BCECgHwhIBD2nevxu8eLFY6ZOnXpbP9SJOkAAAhCAAATKQKDvBFETqmaNLIYOVbT77l3KAJsyQAACEEhLQELodp0zRvG3mg2yKCJAAAIQgAAEIJAhgb4VRK2MJI621udjFD8scfSKDPmRFAQgAIHMCUgEPaVEf6X4S4mgKZlnQIIQgAAEIAABCCwhMBCCqFlbCaOREkTv0Wc7YthD7weq/lz3EIBAeQnonvSSbknXqIRj9PZCCaH55S0tJYMABCAAAQj0D4GBFQRaa7Sh1xqpA3KEmnP9/mlSagIBCFSMwCwJoLMba4PsOpsAAQhAAAIQgECBBAZWELUwHiZxtO/w4cPtiOEAxRUL5E9WEIDAYBLwZqlDixYtsoOEy/Xem6kSIAABCEAAAhDoAQEEUQt0bfr6Sm36epS+svvuzXvQHmQJAQj0MQHNBE1X9cZq89QztXnqk31cVaoGAQhAAAIQqAwBBFFIU2299da7SRTZpO59OmR0ZVqUgkIAAmUjMFdC6ALFMVOmTPlz2QpHeSAAAQhAAAKDTgBBFHMFbLHFFqtq1uhwHWaTuh0H/YKh/hCAQGICf9GRYzQb9Ov77rvvX4nP4kAIQAACEIAABAolgCBKgXvLLbfcTmuNjtWs0Yd02uopTuVQCEBgMAg8o5mg32ht0OnTpk2bOBhVppYQgAAEIACBahNAEHXQfptuuulKI0eOfJ+91On0t3WQBKdAAAL9ReAGe4mbP3/+BTNmzHixv6pGbSAAAQhAAAL9TQBB1GX7brfddhurI+RNX4/QzNE6XSbH6RCAQEUIaCboMRX1bA2M/HLixIkzK1JsigkBCEAAAhCAQBsBBFF2l8RwOWJ4V8MRw35Kdnh2SZMSBCBQEgKLJIQuazhIGK8yLSpJuSgGBCAAAQhAAAIdEkAQdQgu6rRtttlmHQmjo3WMXXhvnEMWJAkBCBRLwDNAZ0oIjZ08ebJnhggQgAAEIAABCPQJAQRRvg25gsTR25WF1xodLJG0Ur7ZkToEIJAVAYkfrwX6k+IYiaDr9PpSVmmTDgQgAAEIQAAC5SGAICqoLTbaaKPVV1lllY80xNF2BWVLNhCAQHoC9g435rnnnjv3oYceeib96ZwBAQhAAAIQgECVCCCIetBamjV6Q0MYfVCzRqv2oAhkCQEItBDQbJD3CTrfQkizQXcCBwIQgAAEIACBwSGAIOphW6+77rorr7766h9ouO9+Uw+LQtYQGFQCt9hd9jPPPPO72bNnvzCoEKg3BCAAAQhAYJAJIIhK0vpbKIwYMcLuu21W96qSFItiQKAfCTyhSp27YMGCX96n0I8VpE4QgAAEIAABCCQngCBKzqqQI3faaacR8+bNe7cysyOGvWRSN6yQjMkEAn1MQCZxi1W9qxTHjBo1atyECRMW9HF1qRoEIAABCEAAAikIIIhSwCr60G233XYD5Xm0OnNHShi9puj8yQ8CVSeg/87f9N85S/UYO2nSpEeqXh/KDwEIQAACEIBA9gQQRNkzzSNFu+/eWwl/TJ07zx6NyCMT0oRAnxBYICE0TnWxg4Qr9Yq77D5pWKoBAQhAAAIQyIMAgigPqjmmKWG0ZmPG6GiJo61yzIqkIVApAvpfTPXGqZ4RkhB6ulKFp7AQgAAEIAABCPSMAIKoZ+i7z1gmdfZM57VG71d8WfcpkgIEKkfgeZX494pjZBJ3S+VKT4EhAAEIQAACEOg5AQRRz5ug+wJo1mgVpXKYxZFGx73HEQECfU1AM0HeK2iM4nmaDXqurytL5SAAAQhAAAIQyJUAgihXvMUnLnG0tUTRseowHq7XNYsvATlCIB8Cuqaf1jX9a72eLhE0JZ9cSBUCEIAABCAAgUEjgCDq0xaXMBqpqh2iaJO6t6sjSVv3aVv3c7UkfuwQ4TpFzwb9UUJofj/Xl7pBAAIQgAAEIFA8ATrJxTMvPMetttpqw2HDhnnTV7vvXrfwApAhBFISkA6arVPOWrx48S+nTp36cMrTORwCEIAABCAAAQgkJoAgSoyqLw4cLkcM+6mz6bVG+6tGK/ZFrahEvxBYqGvzEl2bdpBwmSq1qF8qRj0gAAEIQAACECgvAQRRedsm15Jtsskma40aNeooZXKUOqCb5ZoZiUMggoBE0P36+cx58+ad+cADDzwOLAhAAAIQgAAEIFAkAQRRkbRLmtd22233Ns8aqXheczS6pMWkWP1FYK6q80fPBk2cOPGG/qoatYEABCAAAQhAoEoEEERVaq2cy7rxxhuvNnr06MOVjU3qdsg5O5IfQAIS3ner2mPmzp3765kzZ84ZQARUGQIQgAAEIACBkhFAEJWsQcpSHDli2FGOGCyMvL/RamUpF+WoJIE5EkLnyUHCGDlI+Esla0ChIQABCEAAAhDoWwIIor5t2mwqtv76649ebbXV3teYNdotm1RJZRAISAT92bNBc+bMuWDWrFk2kSNAAAIQgAAEIACB0hFAEJWuScpbIO1ttKlKd4xmjT6q17XLW1JK1kMC/5AQOkf5/1J7Bs3oYTnIGgIQgAAEIAABCCQigCBKhImD2gisKPfdB+g7O2LYR3E4hAaagN1jX6Fod9lDel040DSoPAQgAAEIQAAClSKAIKpUc5WvsJtvvvl6I0aMaLrv3qh8JaREeRHQTNBDSnvsggULzpo+ffqjeeVDuhCAAAQgAAEIQCBPAgiiPOkOVtoryBHDHsOHD/+YOsoHyaxupcGq/mDUVm37otr2okWLFtlBwjWq9UuDUXNqCQEIQAACEIBAvxJAEPVry/awXhtttNHqL3vZy45Qx/loFWPbHhaFrLMjMEliaOzzzz9/9kMPPfRMdsmSEgQgAAEIQAACEOgtAQRRb/n3fe5bb731LhJGXmt0qF5X6fsK91EFJYCeU3V+q9cxU6ZMub2PqkZVIAABCEAAAhCAwBICCCIuhkIIrLvuuiuvueaaH1RmFke7FpIpmXRK4DadOObpp58+f/bs2S90mgjnQQACEIAABCAAgSoQQBBVoZX6rIxbKKy44orHqlof1qzRK/usepWsjmaBnlTBf7Vw4cLT71OoZCUoNAQgAAEIQAACEOiAAIKoA2ickg2BnXbaacTcuXPfM2zYMDti2FPiiOsxG7SJUhHzl4T86sWLF48ZPXr0hRMmTFiQ6EQOggAEIAABCEAAAn1EgA5oHzVmlauifY02UP/8Y+qgH6l6bFDlulSg7I+I9Vli7X2DHqlAeSkiBCAAAQhAAAIQyI0Agig3tCTcIYFhcsSwjx0xKHrz1xEdpsNpyxJYIBE01HCQ4E1UFwMIAhCAAAQgAAEIQKBWQxBxFZSWgDZ9feXIkSM9Y2T33VuUtqDlLpjXA42dP3++N0/1OiECBCAAAQhAAAIQgEALAQQRl0MlCGyzzTZvUUE9a/Q+va5ciUL3rpAvaCboAmU/ZvLkyTf1rhjkDAEIQAACEIAABMpPAEFU/jaihC0E5KBu1REjRnzI4khxJ+AsQ2CCRdCCBQt+I0dx/4INBCAAAQhAAAIQgEA8AQRRPCOOKCmBLbfccrvhw4d/XLNGFkhrlLSYeRfrn5oN+s2iRYvOmDZt2sS8MyN9CEAAAhCAAAQg0G8EEET91qIDWJ9NN910Ja01em/Dfffb+t19d8Nd9g12l621QX+YMWPGiwPY7FQZAhCAAAQgAAEIZEIAQZQJRhIpC4HttttuY7vvVjxCwujVZSlXFuVQnf6uOp1td9kTJ06cmUWapAEBCEAAAhCAAAQGnQCCaNCvgP6t/3A5Ythf1bMjhnfqdXhFq7pIQuhSld0OEi7R66KK1oNiQwACEIAABCAAgVISQBCVslkoVJYEJIzWkag4UsLoaMVNskw7r7RU3gcUx6q8Z0kIPZZXPqQLAQhAAAIQgAAEBp0AgmjQr4DBqv8KEke7q8r2UHewxMaoMlVfAmieyvMnRc8GXa/Xl8pUPsoCAQhAAAIQgAAE+pEAgqgfW5U6xRLYeOONVxs1atRHGrNGr4s9IccDJITu8WzQvHnzzp05c+acHLMiaQhAAAIQgAAEIACBNgIIIi6JgSew7bbbvl4Q7IjhgxJILy8CiPJ6Vnmdr7zGTJo06a4i8iQPCEAAAhCAAAQgAIHlCSCIuCog0CCw/vrrj15ttdU+YHEksfLmPMBICN1sETRnzpzfzZo1a24eeZAmBCAAAQhAAAIQgEByAgii5Kw4coAIaK3RphJFx6rKH1Fcq8uqP67zz5UYOl1rg2Z0mRanQwACEIAABCAAAQhkSABBlCFMkupLAitKHL1bNbMjhr0lkoYlqaXEz2Idd6WiHSSM0+vCJOdxDAQgAAEIQAACEIBAsQQQRMXyJrcKE9h8883XGzFixNGqwlESRhsGVUVC6GF9f+aCBQvGTp8+/dEKV5eiQwACEIAABCAAgYEggCAaiGamkhkTWEGOGPZSmnbE4NmjmgSSZ4HsIOEqveIuO2PgJAcBCEAAAhCAAATyIoAgyoss6Q4Ege233359V/Tee++dNRAVppIQGEACGvhY7lmpQZAlAx9F/96at5sjKP/GQE29jO2/N88PO6/bJnb6eaXdbdnizk9adt37T1q8ePF8bd9w/l133fVIXLr98HtSNp3WNe/0Oy1X+3lB5czqPxXGIC79Xt6PWu81Yfej9ntWVm2RZToIoixpkhYEIAABCEAAAn1PQGtLz1cn79BGB/Cveh1SHK81o95GASuBvr8CqGC/EUAQ9VuLUh8IQAACEIAABHIl0CqIWjPSzNjf9fkSvY5/5plnrpo9e/YLuRaExCEAgUwIIIgywUgiEIAABCAAAQgMCoEwQdQmjuZpFulazxwtWrTooqlTp1osESAAgRISQBCVsFEoEgQgAAEIQAAC5SWQRBC1l16zRndbHCkOybTuTr1iWlfeJqZkA0YAQTRgDU51IQABCEAAAhDojkAngqgtx3/o8yWaORqaM2fOlZjWddcenA2BbgkgiLolyPkQgAAEIAABCAwUgQwE0RJemjl6UR+u88yR9rAbxx52A3UpUdmSEEAQlaQhKAYEIAABCEAAAtUgkKUgCqjxvRJJQ3LrPV7rjm7X75jWVeOyoJQVJoAgqnDjUXQIQAACEIAABIonkLMgaq3Q4/pwieL4YcOGXaE9754vvrbkCIH+J4Ag6v82poYQgAAEIAABCGRIoEBBtKTUDdO66y2O5L1u3KRJkwZiQ9gMm42kIBBKAEHExQEBCEAAAhCAAARSEOiFIAoo3kSLo4ULFw5NmzbNpnWLU1SBQyEAgRYCCCIuBwhAAAIQgAAEIJCCQEkEUWuJn9AM0qX6Ymj48OGXY1qXojE5FAIigCDiMoAABCAAAQhAAAIpCJRQEC0pvYTRfJnU3SCnDENad3QRpnUpGpZDB5YAgmhgm56KQwACEIAABCDQCYEyC6L2+kggTfbMkeJ4bQh7q14xreuk0TmnrwkgiPq6eakcBCAAAQhAAAJZE6iSIGqtu8TRk/p8qV7tmOEyCaTnsmZDehCoIgEEURVbjTJDAAIQgAAEINAzAlUVRG3AFujzDZ45WrRo0UXa8+jhngElYwj0mACCqMcNQPYQgAAEIAABCFSLQJ8IomWga9ZoisWR4pBmjm7RK6Z11bosKW0XBBBEXcDjVAhAAAIQgAAEBo9APwqi1laUOHrKJnV2zDB//vzLZ8yY8ezgtTI1HiQCCKJBam3qCgEIQAACEIBA1wT6XRC1AVoggfRnzxxpz6Nx991334NdAyQBCJSMQOkF0Te+8Y199Ec8T9xu//rXv/7OkvHrqDinnHLKZrLXtd3uqztKgJMgAAEIQAACEIAABCCQHYGn5ab9wK997Ws3Z5dk71KSZjhTuR+imc7PnHzyyefElaT0gkgVOlWVOMEVWWmlldb80pe+9M+4SpX9d4m8oyXyxpS9nJQPAhCAAAQgAAEIQGBgCJyifvfX+qG2qse/VI9VFC/U+4Pj6lQFQXSaKvGpRkXWVqUej6tU2X+XIDpGguiMRjnv0eszZS8z5YMABCAAAQhA4N8E5syZs5XW1qwFj2UIvLTiiivOGTly5FMawH5S7+fBpxIERqmUuzRK+i31s79SiVLHFFL1mKtDXLchvT8wrk4IojhCOfwuQXSsBNEvnLSm8t6hqbzrcsiGJCEAAQhAAAIQyIHAgK0h6pTgfTrR+x0NTZw48Sa9X9RpQpyXHwGJhY2V+gONHL6tz1/OL7fiUkYQFce645wQRB2j40QIQAACEIBAzwkgiFI3wT81EHy5zhqaO3fupTNnzpyTOgVOyIUAgujfWJkhyuXyik4UQdQD6GQJAQhAAAIQyIgAgqgrkAt19s126e04bdq06V2lxsldEUAQIYi6uoC6ORlB1A09zoUABCAAAQj0lgCCKDv+mjm6X6kN2bRu0qRJNq2zYCIURABBhCAq6FJbPhsEUc/QkzEEIAABCECgawIIoq4RhiXwjE3rFMfPmzdvPKZ1uXFekjCCCEGU/1UWkgOCqGfoyRgCEIAABCDQNQEEUdcIkyRgJwzeE6fpmGFakpM4Jh0BBBGCKN0Vk+HRCKIMYZIUBCAAAQhAoGACCKKCgSs7zRrNsDhSHJo8efKNesW0LoNmQBAhiDK4jDpLAkHUGTfOggAEIAABCJSBAIKo561gL3VX2CnD8OHDL5Fb73/2vEQVLQCCCEHUs0sXQdQz9GQMAQhAAAIQ6JoAgqhrhFkmsEizR7d65qjhmGFqlon3e1oIIgRRz65xBFHP0JMxBCAAAQhAoGsCCKKuEeaZwEwJpCHH0aNH3zhhwoQFeWZW9bQRRAiinl3DCKKeoSdjCEAAAhCAQNcEEERdIywkAYmiZzVrdIVnj/T+Eq09erqQjCuUCYIIQdSzyxVB1DP0ZAwBCEAAAhDomgCCqGuEhScgQbRYmdq0brxnj6ZMmTK58EKUMEMEEYKoZ5clgqhn6MkYAhCAAAQg0DUBBFHXCMuQwIMWR549Wmmlla4fVNM6BBGCqGd/RgRRz9CTMQQgAIFSEXj00Uf3lEnPVRGFesO66657V6kKXcHCZM0ZQZT8IvjRj35U23bbbQNPuP3222tf/epXEyeWZVqtmWrG6F/6fKXFkeMgmdYhiBBEif+AWR+IIMqaKOlBAAIQqCaBrDvq1aSQf6mz5owgSt5mWYqYLNMKq4FN6zRIcbtdetu0burUqZOS17Z6RyKIchJEukmcogvppKwuiR122KG26aab1pMbGhqqvfjii1kl3bN0Nt5449qOO+5Yz/+GG26oPfHEEz0rCxlDAAIQgEDvCPzHf/xH7bvf/W5oAT71qU/Vpk+f3rsC9knOcO5dQ2YpYrJMKykRiaKHdOx4u/SWad11/WZahyBCECX9L2R+HIIoc6QkCAEIQKCSBOioF9NscC6Gc1AuWYqYLNPqhIjE0XM6r25at2DBgvEarHiyk3TKdA6CCEHUs+sRQdQz9GQMAQhAoFQE6KgX0xxwLoZzvwui1vo1TOvu8OyRBdKkSZPu7R3lznNGECGIOr96ujwTQdQlQE6HAAQg0CcE6KgX05BwLobzIAmi9rpKIP2tKY70eq0cM8zvHfXkOSOIEETJr5aMj0QQZQyU5CAAAQhUlAAd9WIaDs7FcB5kQdRW9+f12d4jh+bNmzc0Y8aM0i4WRxAhiHp2d0AQdY5+vfXWq5111lnLJKCbTe3AAw/sPFHOhAAEINAjAnTUiwEP52I4I4iWJ6CZo5f07Z0WR46aObqnd62xfM4IIgRRz65HBFHn6Pfcc8/aF77wBQRR5wg5EwIQKBEBOurFNAaci+GMIErE+RFppPF26S3Pddf02rQOQYQgSnTV5nEQgqhzqnZB2z4bxAxR5zw5EwIQ6C0BOurF8IdzMZwRRKk5Py9hdLVdeqsvc3EvTOsQRAii1FdtVicgiDon+bOf/ay22WabMUPUOULOhAAESkSAjnoxjQHnYjgjiDrn3DCtu0speEPY8VOmTPlr56klPxNBhCBKfrVkfCSCqDOg2hCtduGFF9ZWXHFFBFFnCDkLAhAoGQE66sU0CJyL4YwgypTzLKV2iQWSZo+u1uzRi5mm3kgMQRQjiL797W+v8eKLL/4/HfZOxY00nfeBk08+2R4zat/4xjc+PWLEiN9++ctfXs5rxjbbbHOKjj0pq0bbYYcdaptuumk9uaGhoZrKlFXSPUsHQdQZ+u233772gx/8YLmTMZnrjCdnQQACvSdAR72YNoBzMZwRRLlxfkGzRte4K6w+9sXa8+gfWeWEIIoQRN/61rdeNX/+/Nt0yMaK9qM+UnE/Qbu88dtj+vywRNEbv/KVryzTKAii+EsUQRTPKOiI97///bWPfexjCKLO8HEWBCBQQgJ01ItpFDgXwxlBlD9nm9ZJFP3F4mjRokVDU6dO9fuOA4IoQhAJzv/q52ME/OPifoPFT1MQ+TT9/i69XKB4ut6f0NoKCKL4axJBFM8o6AjNUNbe/OY3I4g6w8dZEIBACQnQUS+mUeBcDGcEUfGc1U+frVzH2zHDM888c82sWbPmpikFgihaEM00XEH6jOI6ev/3VkHUEEWnNb77tz1bIyCI4i9DBFE8o6Ajfvvb39bWXHNNBFFn+DgLAhAoIQE66sU0CpyL4Ywg6h3nRs5zW0zrxiUxrUMQRQui+VKax2hE/pwwQaR1REcK+s/1+2gEUbo/QJUE0corr1zbaKON6vEVr3hFbfTo0TV/51dN1da8fmfu3Lm1Z599tqZRidojjzxSmz17dm3hwoXpoMQcvfbaa9d+9atfBR7V7RqiNdZYo7bKKqsEpq3Rltq//vWvwN922WWX2hvf+MballtuWWfzspe9rM7j8ccfr11++eW1iy66KBMGr371q2sbbrhhPbqs5j9q1KglbSDz1prL+fTTT9f5P/DAA7XHHrNVK6EfCWywwQa1bbfdtub7iK8NDxL4erCzkeeff75+vfr/6OtAXopq9913X/26JIQT6CXTXnXUfb1svfXW9bjJJpvUr6VXvvKV9fvKyJEj6/d3r9n1teT7ie/rMs2pTZw4sfaPf2S2fKGwy7IbzuoP1bbYYovaG97whtprX/va2vrrr19bbbXV6qy0dKD+//L/zowefPDB2j333FP761//2hdrnrNooB/96Ef1e1ZQuP3222tf/epXE2eTZVpxmfre6ud6VPj73/+eeX8nrlwpf6+b1imOlziyB7vlAoLo30hWCIEzx44RJIhOixBEJ0oQfVG/r9GaBjNE8Zdq2QWR3VrvvvvudfO0ddddN75CbUf4IXr33XfXbrvtttrNN99c76ynCVqnVnv961+f5pTYY0888cT6AyooHH/88bWDDjoo8Ldzzz239utf/3qZ39x5cHoWiWHhz3/+c+2UU06JLVfQAfam5/rvtttuNYuuuBtyUBoWZbfcckvtqquuqt1///0dleO73/1uzZ2IoHD11VfXvve973WUbvtJ66yzTs2co8IRRxxR72xkEbwOzevRgoKv2/aNf7PIs9s0/GB+17veVXvHO96R+j+5YMGC2k033VS7+OKLa9oAMHFRTjjhhNo732mfOsHBDk6uvPLKxOl1eqCeMbU3velNoacfd9xxtZkzbdSQLvSCaVAJu+mop6vxv4/2/evd7353/f6+6qqrdpJEbfr06TXfAzzwUxWxHcf5k5/85HL3St97/b8zL4vFNMGDE9dee23Nlg1PPLGc/6k0SdW22mqr2k9+8pPQcywoLCyyDP/3f/9Xv1aCQtrnW5YiJsu0oni5H+R7nEVvWPA99ac//WmW2HNNS312W3uNd5wzZ85VTdM6BNG/sYcJomv128qKfgqtpbiMydz//M//bKAZgFv1/VSB3Ku1BRFE8ddzWQWRR7+OOeaYyI5+fO2WPcLi6LLLLqtdcMEFiR8KRQuiqA7y7373u9rYsWOXVMpeD3X910dQo0LaB4bTcpredPbQCAKTKQAAIABJREFUQw+tvfzlL0+LOvR4C8EzzjijPmOQJrzvfe+r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aP09ugIKjF6gdGHeo0tNs6rxjqM/ojUooIACCijwvIAJUR+8E/KHBON3GMPERBCML3JRQAEFJp1APsuYsZKxkkyCw4QLLEwWw8xAjId8YNJdlCesgAIKKDDhBUyIJvwt8gQVUECBwRMoY4uWSBLEDJ4uCiiggAIKjJuACdG40VqxAgoooIACCiiggAIKTHQBE6KJfoc8PwUUUEABBRRQQAEFFBg3AROicaO1YgUUUEABBRRQQAEFFJjoAiZEE/0OeX4KKKCAAgoooIACCigwbgImRONGa8UKKKCAAgoooIACCigw0QVMiCb6HfL8FFBAAQUUUEABBRRQYNwEek2IdhzhTK7u9BsRmT513exHtF2y3wXjdoVWrIACCiiggAIKKKCAAgp0ykWUUUABBRRQQAEFFFBAAQUGVaCnFqJBRfK6FVBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIj68756VQoooIACCiiggAIKKFBDwISoBpJFFFBAAQUUUEABBRRQoD8FTIjG+L4uWLBglVS55mKLLfZ7qs7rrfOwdV5/urwecfsYn86oq8v5L5VK3pq4Ldfw1KgrtAIFFFBAAQUUUEABBSaQgAnRGN+MJBBbpso9kzxsWxKgDfO4YV6fWF6PuH2MT2fU1eV6XpVKTk8clGuYO+oKrUABBRQYQSCfOe/I5jckXpN4ceJvibn5/PmtcAoooIACCoyHQN8kRLRk5AvzX70gZZ8XZZ/netmnU9nq+K0JUWv5btt7PZeFvYbst3Su/ZluxzMh6ibkdgUUGAuBfNasnnq+mHhth/ruz/rj/cfMWGhb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)!important;background-size:100% 100%!important;background-origin:content-box!important;background-repeat:no-repeat!important&quot; width=836 height=878></canvas><input style=&quot;display:none;position:absolute;left:0px;top:0px;background:rgba(0,0,0,0.3);color:white;border:medium none;--darkreader-inline-bgcolor:rgba(0,0,0,0.3);--darkreader-inline-bgimage:none;--darkreader-inline-color:#e8e6e3;--darkreader-inline-border-top:currentcolor;--darkreader-inline-border-right:currentcolor;--darkreader-inline-border-bottom:currentcolor;--darkreader-inline-border-left:currentcolor&quot; data-darkreader-inline-bgcolor data-darkreader-inline-bgimage data-darkreader-inline-color data-darkreader-inline-border-top data-darkreader-inline-border-right data-darkreader-inline-border-bottom data-darkreader-inline-border-left value></div><div style=position:fixed;right:0px;top:0px;width:30px;height:30px;z-index:1000;background-color:white;text-align:center;line-height:27px;cursor:pointer;--darkreader-inline-bgcolor:#181a1b data-darkreader-inline-bgcolor>⇱</div>" frameborder=0></iframe></div>
 <div style=width:10px;height:100%;float:right;padding-left:0px;padding-right:0px></div>
 <h1 style=padding-top:10px>Antimatter: an algorithm that prunes CRDT/OT history</h1>
 <p>Michael Toomim and Greg Little<br>
 <a href=https://invisible.college/>Invisible College</a> – <a href=https://braid.org/>Braid Project</a><br></p>
 
 <p><i>Draft</i></p>
 <p style=padding:10px>Antimatter is the world's first peer-to-peer sequence synchronization algorithm that can prune its history in a network where peers disconnect, reconnect, and merge offline edits. In general, sequence CRDTs work by storing a history of edits forever, so that they can always merge with peers after disconnecting from them for an arbitrary amount of time. It is challenging to know exactly which bits of information need to be stored in order to merge with arbitrary peers after arbitrary times, especially in a peer-to-peer network. The anitmatter algorithm is specifically aimed at this challenge, and does the hard work of efficiently keeping track of these details.</p>
 <p>Antimatter supports arbitrary simultaneous edits, from arbitrary peers, under arbitrary network delays and partitions, and guarantees full CRDT/OT consistency, while pruning unnecessary history within each partitioned subnet, and across subnets once they reconnect. In steady state, it prunes down to zero overhead. This lets you put synchronizing data structures in more parts of your software, without worrying about memory overhead.</p>
 
 <h1>Things it does</h1>
 <ul>
 <li>CRDT / OT guarantees full consistency
 <li>Prunes history down to zero after acknowledgements (2 network round trips)
 <li>Arbitrary network topology (hub/spoke, mesh)
 <li>New peers can be added to the network anywhere at any time
 <li>Arbitrary disconnects and reconnects, at arbitrary times
 <li>Peers that connect and disconnect on a stable network don't have to send any information at all to other peers.
 <li>Prune disconnected subnets while offline
 <ul><li>Even if the subnets recursively break up themselves, and then reconnect</ul>
 <li>Peers do not need to be known
 <ul><li>No peer needs to know all the other peers
 <li>Thus you can scale a whole cloud in any subnet
 <li>It just keeps track of disconnection events</ul>
 <li>Doesn't need a rename-version operation
 <li>*think of other features we might want to show*
 <ul><li>disconnection event information is not intertwined with the datastructure, allowing specific disconnections to be discarded without affecting other disconnection event information, or the system as a whole, e.g., information for specific events can be discarded after some time interval (though at the cost of not being able to reconnect seamlessly with prior peers involved with that disconnection event)</ul>
 </ul>
 <h1>How it works</h1>
 <ul>
 <li><h3>acknowledgments</h3> A system of acknowledgments is used to establish whether certain versions always appear together, meaning that every peer who has one of the versions, also has all the other versions.</li>
 <li><h3>blooping</h3> Once it has been established that certain versions always appear together, if they take a certain from, they can be "blooped" together to become a single version</li>
 <li><h3>fissures</h3> If the system of acknowledgments is interrupted by someone disconnected, a system of fissures is used to establish when everyone has reconnected.</li>
 </ul>
 
 <p style=position:relative!important>
 <video style=width:500px controls poster="data:image/png;base64,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"><template shadowroot=closed><div class=videocontrols xmlns=http://www.w3.org/1999/xhtml role=none localedir=ltr>
 
 
 <div id=controlsContainer class=controlsContainer role=none>
 <div id=statusOverlay class="statusOverlay stackItem" hidden>
 <div id=statusIcon class=statusIcon type=throbber></div>
 <bdi class=statusLabel id=errorAborted data-l10n-id=videocontrols-error-aborted>Video loading stopped.</bdi>
 <bdi class=statusLabel id=errorNetwork data-l10n-id=videocontrols-error-network>Video playback aborted due to a network error.</bdi>
 <bdi class=statusLabel id=errorDecode data-l10n-id=videocontrols-error-decode>Video can’t be played because the file is corrupt.</bdi>
 <bdi class=statusLabel id=errorSrcNotSupported data-l10n-id=videocontrols-error-src-not-supported>Video format or MIME type is not supported.</bdi>
 <bdi class=statusLabel id=errorNoSource data-l10n-id=videocontrols-error-no-source>No video with supported format and MIME type found.</bdi>
 <bdi class=statusLabel id=errorGeneric data-l10n-id=videocontrols-error-generic>Video playback aborted due to an unknown error.</bdi>
 </div>
 <div id=pictureInPictureOverlay class="pictureInPictureOverlay stackItem" status=pictureInPicture hidden>
 <div class=statusIcon type=pictureInPicture></div>
 <bdi class=statusLabel id=pictureInPicture data-l10n-id=videocontrols-status-picture-in-picture>This video is playing in Picture-in-Picture mode.</bdi>
 </div>
 <div id=controlsOverlay class="controlsOverlay stackItem" role=none>
 <div class=controlsSpacerStack>
 <div id=controlsSpacer class="controlsSpacer stackItem" role=none></div>
 <button id=clickToPlay class=clickToPlay data-l10n-id=videocontrols-play-button style=width:48.15px;height:48.15px aria-label=Play></button>
 </div>
 <button id=pictureInPictureToggle class=pip-wrapper position=right medium-video has-used>
 <div class="pip-small clickable"></div>
 <div class="pip-expanded clickable">
 <span class="pip-icon-label clickable">
 <span class=pip-icon></span>
 <span class=pip-label data-l10n-id=videocontrols-picture-in-picture-toggle-label2>Pop out this video</span>
 </span>
 <div class="pip-explainer clickable" data-l10n-id=videocontrols-picture-in-picture-explainer3>More screens are more fun. Play this video while you do other things.</div>
 </div>
 <div class="pip-icon clickable"></div>
 </button>
 <div id=controlBar class=controlBar role=none>
 <button id=playButton class="button playButton" paused=true data-l10n-id=videocontrols-play-button aria-label=Play></button>
 <div id=scrubberStack class="scrubberStack progressContainer" role=none>
 <div class="progressBackgroundBar stackItem" role=none>
 <div class=progressStack role=none>
 <progress id=bufferBar class=bufferBar value=4389800 max=9052320 aria-hidden=true></progress>
 <span class=a11y-only role=status aria-live=off>
 <span data-l10n-id=videocontrols-buffer-bar-label>Loading:</span>
 <span id=bufferA11yVal>48%</span>
 </span>
 <progress id=progressBar class=progressBar value=47.9987450730862 max=100 aria-hidden=true></progress>
 </div>
 </div>
 <input type=range id=scrubber class=scrubber data-l10n-attrs=aria-valuetext value max=9052320 data-l10n-args='{"position":"1:12:25","duration":"2:30:52"}' data-l10n-id=videocontrols-scrubber-position-and-duration aria-label=Position aria-valuetext="1:12:25 / 2:30:52">
 </div>
 <bdi id=positionLabel class=positionLabel role=presentation></bdi>
 <bdi id=durationLabel class=durationLabel role=presentation></bdi>
 <bdi id=positionDurationBox class=positionDurationBox aria-hidden=true data-l10n-args='{"position":"1:12:25","duration":"2:30:52"}' data-l10n-id=videocontrols-position-and-duration-labels>1:12:25<span id=durationSpan class=duration role=none data-l10n-name=position-duration-format> / 2:30:52</span></bdi>
 <div id=controlBarSpacer class=controlBarSpacer role=none hidden></div>
 <button id=muteButton class="button muteButton" data-l10n-id=videocontrols-mute-button aria-label=Mute></button>
 <div id=volumeStack class="volumeStack progressContainer" role=none>
 <input type=range id=volumeControl class=volumeControl min=0 max=100 step=1 data-l10n-id=videocontrols-volume-control aria-label=Volume value>
 </div>
 <button id=castingButton class="button castingButton" data-l10n-id=videocontrols-casting-button-label aria-label="Cast to Screen" hidden></button>
 <button id=closedCaptionButton class="button closedCaptionButton" aria-controls=textTrackList aria-haspopup=menu aria-expanded=false data-l10n-id=videocontrols-closed-caption-button aria-label="Closed Captions" hidden></button>
 <div id=textTrackListContainer class=textTrackListContainer role=presentation hidden>
 <div id=textTrackList role=menu class=textTrackList data-l10n-id=videocontrols-closed-caption-off data-l10n-attrs=offlabel offlabel=Off><button class=textTrackItem index=0 role=menuitemradio aria-checked=true>Off</button></div>
 </div>
 <button id=fullscreenButton class="button fullscreenButton" data-l10n-id=videocontrols-enterfullscreen-button aria-label="Full Screen"></button>
 </div>
 </div>
 </div>
 </div></template><source type=video/mp4></video><a href="https://invisiblecollege.s3-us-west-1.amazonaws.com/invisible-college-online8.mp4#t=4345" target=_blank style=z-index:2147483647!important;position:absolute!important;top:8px!important;left:8px!important;width:16px!important;height:16px!important;min-width:16px!important;min-height:16px!important;max-width:16px!important;max-height:16px!important><img src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8H+DhhoQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJJJREFUOI3t070NRCEMA2CnYAOyDyPwpHj/Va7hJ3FzV7zy3ET5JIwoAF6Jk4wzAJAkzxAYG9YRTgB+24wBgKmfrGAKTcEfAY4KRlRoIeBTgKOCERVaCPgU4Khge2GqKOBTgKOCERVaAEC/4PNcnyoSWHpjqkhwKxbcig0Q6AorXYF/+A6eIYD1lVbwG/jdA6/kA2THRAURVubcAAAAAElFTkSuQmCC style=width:16px!important;height:16px!important;min-width:16px!important;min-height:16px!important;max-width:16px!important;max-height:16px!important></a>
 </p>
 </div><h1 style=margin-left:10px;margin-right:10px>Software Architecture</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>The software is architected into three objects:</p>
<pre><code class=language-js>var {create_antimatter_crdt, create_json_crdt, sequence_crdt} = require('@braidjs/antimatter')
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage><span class=hljs-comment>// v502</span>

</pre></div><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><ul>
<li><em>antimatter_crdt</em>: created using <code>create_antimatter_crdt</code>, this object is a json_crdt with antimatter algorithm methods added to it so that it can communicate with other peers to learn which history can be pruned, and tells the underlying json_crdt object to prune it.</li>
</ul>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage><span class=hljs-keyword>var</span> antimatter = {}    <span class=hljs-comment>// The antimatter algorithm</span>
</pre></div><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><ul>
<li><em>json_crdt</em>: created using <code>create_json_crdt</code>, this object is a pruneable JSON CRDT — "JSON" meaning it represents an arbitrary JSON datstructure, and "CRDT" and "pruneable" having the same meaning as for sequence_crdt below. The json_crdt makes recursive use of sequence_crdt structures to represent arbitrary JSON (for instance, a map is represented with a sequence_crdt structure for each value, where the first element in the sequence is the value).</li>
</ul>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage><span class=hljs-keyword>var</span> json = {}          <span class=hljs-comment>// A json crdt</span>
</pre></div><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><ul>
<li><em>sequence_crdt</em>: methods to manipulate a pruneable sequence CRDT — "sequence" meaning it represents a javascript string or array, "CRDT" meaning this structure can be merged with other ones, and "pruneable" meaning that it supports an operation to remove meta-data when it is no longer needed (whereas CRDT's often keep track of this meta-data forever).</li>
</ul>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage><span class=hljs-keyword>var</span> sequence = {}      <span class=hljs-comment>// A sequence crdt</span>

<span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> <span class="hljs-variable language_">module</span> != <span class=hljs-string>'undefined'</span>) <span class="hljs-variable language_">module</span>.<span class=hljs-property>exports</span> = {antimatter, json, sequence}

;(<span class=hljs-function>() =&gt;</span> {
    antimatter.<span class=hljs-property>create</span> = <span class=hljs-function>(<span class=hljs-params>send, self</span>) =&gt;</span> {
        self = json.<span class="hljs-title function_">create</span>(self)
        self.<span class=hljs-property>send</span> = send

        self.<span class=hljs-property>id</span> = self.<span class=hljs-property>id</span> ?? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class=hljs-number>36</span>).<span class="hljs-title function_">slice</span>(<span class=hljs-number>2</span>)
        self.<span class=hljs-property>next_seq</span> = self.<span class=hljs-property>next_seq</span> ?? <span class=hljs-number>0</span>

        self.<span class=hljs-property>conns</span> = self.<span class=hljs-property>conns</span> ?? {}
        self.<span class=hljs-property>proto_conns</span> = self.<span class=hljs-property>proto_conns</span> ?? {}

        self.<span class=hljs-property>version_cache</span> = self.<span class=hljs-property>version_cache</span> ?? {}
        self.<span class=hljs-property>fissures</span> = self.<span class=hljs-property>fissures</span> ?? {}
        self.<span class=hljs-property>acked_boundary</span> = self.<span class=hljs-property>acked_boundary</span> ?? {}
        self.<span class=hljs-property>unack_boundary</span> = self.<span class=hljs-property>unack_boundary</span> ?? {}
        self.<span class=hljs-property>acks_in_process</span> = self.<span class=hljs-property>acks_in_process</span> ?? {}
        self.<span class=hljs-property>forget_cbs</span> = self.<span class=hljs-property>forget_cbs</span> ?? {}

</pre></div><h1 style=margin-left:10px;margin-right:10px>create_antimatter_crdt(send[, init])</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Creates and returns a new antimatter_crdt object (or adds antimatter_crdt methods and properties to <code>init</code>).</p>
<ul>
<li><code>send</code>: A callback function to be called whenever this antimatter_crdt wants to send a message over a connection registered with <code>get</code> or <code>connect</code>. The sole parameter to this function is a JSONafiable object that hopes to be passed to the <code>receive</code> method on the antimatter_crdt object at the other end of the connection specified in the <code>conn</code> key.</li>
<li><code>init</code>: (optional) An antimatter_crdt object to start with, which we'll add any properties to that it doesn't have, and we'll add all the antimatter_crdt methods to it. This option exists so you can serialize an antimatter_crdt instance as JSON, and then restore it later.</li>
</ul>
<pre><code class=language-js>var antimatter_crdt = create_antimatter_crdt(msg =&gt; {
    websockets[msg.conn].send(JSON.stringify(msg))
}, JSON.parse(fs.readFileSync('./antimatter.backup')))
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>receive</span> = <span class=hljs-function>(<span class=hljs-params>{cmd, version, parents, patches, versions, fissure, fissures, seen, forget, peer, conn}</span>) =&gt;</span> {
        
</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.receive(message)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Let this antimatter object "receive" a message from another antimatter object, presumably from its <code>send</code> callback.</p>
<pre><code class=language-js>websocket.on('message', data =&gt; {
    antimatter_crdt.receive(JSON.parse(data))
});
</code></pre>
<p>You generally do not need to mess with a message object directly, but below are the various message objects you might see, categorized by their <code>cmd</code> entry. Note that each object also contains a <code>conn</code> entry with the id of the connection the message is sent over.</p>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'get'</span> || (cmd == <span class=hljs-string>'welcome'</span> &amp;&amp; peer != <span class=hljs-literal>null</span>)) {
                <span class=hljs-keyword>if</span> (self.<span class=hljs-property>conns</span>[conn] != <span class=hljs-literal>null</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                self.<span class=hljs-property>conns</span>[conn] = peer

                <span class="hljs-title function_">send</span>({
                    <span class=hljs-attr>cmd</span>: <span class=hljs-string>'welcome'</span>,
                    <span class=hljs-attr>versions</span>: self.<span class="hljs-title function_">generate_braid</span>(parents),
                    <span class=hljs-attr>fissures</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(self.<span class=hljs-property>fissures</span>),
                    <span class=hljs-attr>parents</span>: parents &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(parents).<span class=hljs-property>length</span> ? self.<span class="hljs-title function_">get_leaves</span>(self.<span class="hljs-title function_">ancestors</span>(parents, <span class=hljs-literal>true</span>)) : {},
                    ... cmd == <span class=hljs-string>'get'</span> ? {<span class=hljs-attr>peer</span>: self.<span class=hljs-property>id</span>} : {},
                    conn
                })
            }

</pre></div><h1 style=margin-left:10px;margin-right:10px>message `fissure`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent to alert peers about a fissure. The <code>fissure</code> entry contains information about the two peers involved in the fissure, the specific connection id that broke, the <code>versions</code> that need to be protected, and the <code>time</code> of the fissure (in case we want to ignore it after some time). It is also possible to send multiple <code>fissures</code> in an array.</p>
<pre><code class=language-js>{
    cmd: 'fissure',
    fissure: { // or fissures: [{...}, {...}, ...],
        a: 'PEER_A_ID',
        b: 'PEER_B_ID',
        conn: 'CONN_ID',
        versions: {'VERSION_ID': true, ...},
        time: Date.now()
    },
    conn: 'CONN_ID'
}
</code></pre>
<p>Note that <code>time</code> isn't used for anything critical, as it's just wallclock time.</p>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'forget'</span>) {
                <span class=hljs-keyword>if</span> (self.<span class=hljs-property>conns</span>[conn] == <span class=hljs-literal>null</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'ack'</span>, <span class=hljs-attr>forget</span>: <span class=hljs-literal>true</span>, conn})

                <span class=hljs-keyword>delete</span> self.<span class=hljs-property>conns</span>[conn]
                <span class=hljs-keyword>delete</span> self.<span class=hljs-property>proto_conns</span>[conn]
</pre></div><h1 style=margin-left:10px;margin-right:10px>message `get`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p><code>get</code> is the first message sent over a connection, and the peer at the other end will respond with <code>welcome</code>.</p>
<pre><code class=language-js>{
  cmd: 'get',
  peer: 'SENDER_ID',
  conn: 'CONN_ID',
  parents: {'PARENT_VERSION_ID': true, ...}
}
</code></pre>
<p>The <code>parents</code> are optional, and describes which versions this peer already has. The other end will respond with versions since that set of parents.</p>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'ack'</span> &amp;&amp; forget) {
                self.<span class=hljs-property>forget_cbs</span>[conn]()
</pre></div><h1 style=margin-left:10px;margin-right:10px>message `forget`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Used to disconnect without creating a fissure, presumably meaning the sending peer doesn't plan to make any edits while they're disconnected.</p>
<pre><code class=language-js>{cmd: 'forget', conn: 'CONN_ID'}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'fissure'</span>) {
                <span class=hljs-keyword>if</span> (fissure &amp;&amp; fissures) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                <span class=hljs-keyword>if</span> (!fissures) fissures = [fissure]

                <span class=hljs-keyword>let</span> new_fissures = []
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> fissure <span class=hljs-keyword>of</span> fissures) {
                    <span class=hljs-keyword>var</span> key = fissure.<span class=hljs-property>a</span> + <span class=hljs-string>':'</span> + fissure.<span class=hljs-property>b</span> + <span class=hljs-string>':'</span> + fissure.<span class=hljs-property>conn</span>
                    <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>fissures</span>[key]) {
                        self.<span class=hljs-property>fissures</span>[key] = fissure
                        new_fissures.<span class="hljs-title function_">push</span>(fissure)
                        self.<span class=hljs-property>acks_in_process</span> = {}
                    }
                }
                <span class=hljs-keyword>let</span> extra_fissures = <span class="hljs-title function_">resolve_fissures</span>()
                new_fissures = new_fissures.<span class="hljs-title function_">concat</span>(extra_fissures)

                <span class=hljs-keyword>if</span> (extra_fissures.<span class=hljs-property>length</span>) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'fissure'</span>, <span class=hljs-attr>fissures</span>: extra_fissures, conn})
                <span class=hljs-keyword>if</span> (new_fissures.<span class=hljs-property>length</span>) <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class=hljs-keyword>if</span> (c != conn) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'fissure'</span>, <span class=hljs-attr>fissures</span>: new_fissures, <span class=hljs-attr>conn</span>: c})
</pre></div><h1 style=margin-left:10px;margin-right:10px>message forget `ack`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent in response to <code>forget</code>.. so they know we forgot them.</p>
<pre><code class=language-js>{cmd: 'ack', forget: true, conn: 'CONN_ID'}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'set'</span>) {
                <span class=hljs-keyword>if</span> (conn == <span class=hljs-literal>null</span> || !self.<span class=hljs-property>T</span>[version]) {
                    <span class=hljs-keyword>let</span> ps = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(parents)
                    <span class=hljs-keyword>if</span> (!ps.<span class=hljs-property>length</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>).<span class=hljs-property>length</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                    <span class=hljs-keyword>for</span> (p <span class=hljs-keyword>of</span> ps) <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[p]) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                    
                    <span class=hljs-keyword>var</span> rebased_patches = self.<span class="hljs-title function_">add_version</span>(version, parents, patches)
                    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class=hljs-keyword>if</span> (c != conn) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'set'</span>, version, parents, patches, <span class=hljs-attr>conn</span>: c})

                    self.<span class=hljs-property>acks_in_process</span>[version] = {<span class=hljs-attr>origin</span>: conn, <span class=hljs-attr>count</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>).<span class=hljs-property>length</span> - (conn != <span class=hljs-literal>null</span> ? <span class=hljs-number>1</span> : <span class=hljs-number>0</span>)}
                } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (self.<span class=hljs-property>acks_in_process</span>[version]) self.<span class=hljs-property>acks_in_process</span>[version].<span class=hljs-property>count</span>--

                <span class="hljs-title function_">check_ack_count</span>(version)
                <span class=hljs-keyword>return</span> rebased_patches
</pre></div><h1 style=margin-left:10px;margin-right:10px>message `set`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent to alert peers about a change in the document. The change is represented as a version, with a unique id, a set of parent versions (the most recent versions known before adding this version), and an array of patches, where the offsets in the patches do not take into account the application of other patches in the same array.</p>
<pre><code class=language-js>{
    cmd: 'set',
    version: 'VERSION_ID',
    parents: {'PARENT_VERSION_ID': true, ...},
    patches: [
        {range: '.json.path.a.b', content: 42}, ...
    ],
    conn: 'CONN_ID'
}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'ack'</span> &amp;&amp; seen == <span class=hljs-string>'local'</span>) {
                <span class=hljs-keyword>if</span> (self.<span class=hljs-property>acks_in_process</span>[version]) {
                    self.<span class=hljs-property>acks_in_process</span>[version].<span class=hljs-property>count</span>--
                    <span class="hljs-title function_">check_ack_count</span>(version)
                }
</pre></div><h1 style=margin-left:10px;margin-right:10px>message `marco`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent for pruning purposes, to try and establish whether everyone has seen the most recent versions. Note that a <code>set</code> message is treated as a <code>marco</code> message for the version being set.</p>
<pre><code class=language-js>{
    cmd: 'marco',
    version: 'MARCO_ID',
    versions: {'VERSION_ID_A': true, ...},
    conn: 'CONN_ID'
}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'ack'</span> &amp;&amp; seen == <span class=hljs-string>'global'</span>) {
                <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[version]) <span class=hljs-keyword>return</span>
                <span class=hljs-keyword>if</span> (self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>unack_boundary</span>)[version]) <span class=hljs-keyword>return</span>                
                <span class=hljs-keyword>if</span> (self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>acked_boundary</span>)[version]) <span class=hljs-keyword>return</span>
                <span class="hljs-title function_">add_full_ack_leaf</span>(version)
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class=hljs-keyword>if</span> (c != conn) <span class="hljs-title function_">send</span>({cmd, seen, version, <span class=hljs-attr>conn</span>: c})

            }

</pre></div><h1 style=margin-left:10px;margin-right:10px>message local `ack`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent in response to <code>set</code>, but not right away; a peer will first send the <code>set</code> over all its other connections, and only after they have all responded with a local <code>ack</code> – and we didn't see a <code>fissure</code> message while waiting – will the peer send a local <code>ack</code> over the originating connection.</p>
<pre><code class=language-js>{cmd: 'ack', seen: 'local', version: 'VERSION_ID', conn: 'CONN_ID'}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>            <span class=hljs-keyword>if</span> (cmd == <span class=hljs-string>'welcome'</span>) {
                <span class=hljs-keyword>var</span> versions_to_add = {}
                versions.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> versions_to_add[v.<span class=hljs-property>version</span>] = v.<span class=hljs-property>parents</span>)
                versions.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> {
                    <span class=hljs-keyword>if</span> (self.<span class=hljs-property>T</span>[v.<span class=hljs-property>version</span>]) {
                        <span class="hljs-title function_">remove_ancestors</span>(v.<span class=hljs-property>version</span>)
                        <span class=hljs-keyword>function</span> <span class="hljs-title function_">remove_ancestors</span>(<span class=hljs-params>v</span>) {
                            <span class=hljs-keyword>if</span> (versions_to_add[v]) {
                                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(versions_to_add[v]).<span class="hljs-title function_">forEach</span>(remove_ancestors)
                                <span class=hljs-keyword>delete</span> versions_to_add[v]
                            }
                        }
                    }
                })

                <span class=hljs-keyword>var</span> rebased_patches = []
                <span class=hljs-keyword>var</span> added_versions = []
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> v <span class=hljs-keyword>of</span> versions) {
                    <span class=hljs-keyword>if</span> (versions_to_add[v.<span class=hljs-property>version</span>]) {
                        <span class=hljs-keyword>let</span> ps = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(v.<span class=hljs-property>parents</span>)
                        <span class=hljs-keyword>if</span> (!ps.<span class=hljs-property>length</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>).<span class=hljs-property>length</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                        <span class=hljs-keyword>for</span> (p <span class=hljs-keyword>of</span> ps) <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[p]) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)

                        rebased_patches = rebased_patches.<span class="hljs-title function_">concat</span>(self.<span class="hljs-title function_">add_version</span>(v.<span class=hljs-property>version</span>, v.<span class=hljs-property>parents</span>, v.<span class=hljs-property>patches</span>, v.<span class=hljs-property>sort_keys</span>))
                        added_versions.<span class="hljs-title function_">push</span>(v)
                    }
                }

                <span class=hljs-keyword>var</span> new_fissures = []
                fissures.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>f</span> =&gt;</span> {
                    <span class=hljs-keyword>var</span> key = f.<span class=hljs-property>a</span> + <span class=hljs-string>':'</span> + f.<span class=hljs-property>b</span> + <span class=hljs-string>':'</span> + f.<span class=hljs-property>conn</span>
                    <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>fissures</span>[key]) {
                        new_fissures.<span class="hljs-title function_">push</span>(f)
                        self.<span class=hljs-property>fissures</span>[key] = f
                    }
                })
                <span class=hljs-keyword>let</span> extra_fissures = <span class="hljs-title function_">resolve_fissures</span>()
                new_fissures = new_fissures.<span class="hljs-title function_">concat</span>(extra_fissures)

                <span class=hljs-keyword>if</span> (extra_fissures.<span class=hljs-property>length</span>) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'fissure'</span>, <span class=hljs-attr>fissures</span>: extra_fissures, conn})
                <span class=hljs-keyword>if</span> (added_versions.<span class=hljs-property>length</span> || new_fissures.<span class=hljs-property>length</span>) {
                    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class=hljs-keyword>if</span> (c != conn) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'welcome'</span>, <span class=hljs-attr>versions</span>: added_versions, <span class=hljs-attr>fissures</span>: new_fissures, <span class=hljs-attr>conn</span>: c})
                }

                self.<span class=hljs-property>acks_in_process</span> = {}

                <span class=hljs-keyword>return</span> rebased_patches
            }
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>message global `ack`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent after an originating peer has received a local <code>ack</code> over all its connections, or after any peer receives a global <code>ack</code>, so that everyone may come to know that this version has been seen by everyone in this peer group.</p>
<pre><code class=language-js>{cmd: 'ack', seen: 'global', version: 'VERSION_ID', conn: 'CONN_ID'}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>get</span> = <span class=hljs-function><span class=hljs-params>conn</span> =&gt;</span> {
            self.<span class=hljs-property>proto_conns</span>[conn] = <span class=hljs-literal>true</span>
            <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'get'</span>, <span class=hljs-attr>peer</span>: self.<span class=hljs-property>id</span>, conn})
        }
        self.<span class=hljs-property>connect</span> = self.<span class=hljs-property>get</span>

</pre></div><h1 style=margin-left:10px;margin-right:10px>message `welcome`</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Sent in response to a <code>get</code>, basically contains the initial state of the document; incoming <code>welcome</code> messages are also propagated over all our other connections (but only with information that was new to us, so that the propagation will eventually stop). When sent in response to a <code>get</code> (rather than being propogated), we include a <code>peer</code> entry with the id of the sending peer, so they know who we are, and to trigger them to send us their own <code>welcome</code> message.</p>
<pre><code class=language-js>{
    cmd: 'welcome',
    versions: [each version looks like a set message...],
    fissures: [each fissure looks as it would in a fissure message...],
    parents: {'PARENT_VERSION_ID': true,
        ...versions you must have before consuming these new versions},
    [ peer: 'SENDER_ID', ] // if sent in response to a get
    conn: 'CONN_ID'
}
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>forget</span> = <span class=hljs-keyword>async</span> conn =&gt; {
            <span class=hljs-keyword>await</span> <span class=hljs-keyword>new</span> <span class="hljs-title class_">Promise</span>(<span class=hljs-function><span class=hljs-params>done</span> =&gt;</span> {
                <span class=hljs-keyword>if</span> (self.<span class=hljs-property>conns</span>[conn] != <span class=hljs-literal>null</span>) {
                    self.<span class=hljs-property>forget_cbs</span>[conn] = done
                    <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'forget'</span>, conn})
                }
                self.<span class="hljs-title function_">disconnect</span>(conn, <span class=hljs-literal>false</span>)
            })
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.get(conn) or connect(conn)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Register a new connection with id <code>conn</code> – triggers this antimatter_crdt object to send a <code>get</code> message over the given connection.</p>
<pre><code class=language-js>alice_antimatter_crdt.get('connection_to_bob')
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>disconnect</span> = <span class=hljs-function>(<span class=hljs-params>conn, fissure=<span class=hljs-literal>true</span></span>) =&gt;</span> {
            <span class=hljs-keyword>if</span> (self.<span class=hljs-property>conns</span>[conn] == <span class=hljs-literal>null</span> &amp;&amp; !self.<span class=hljs-property>proto_conns</span>[conn]) <span class=hljs-keyword>return</span>
            <span class=hljs-keyword>delete</span> self.<span class=hljs-property>proto_conns</span>[conn]

            <span class=hljs-keyword>if</span> (self.<span class=hljs-property>conns</span>[conn] == <span class=hljs-literal>null</span>) {
                <span class=hljs-keyword>let</span> new_fissures = <span class="hljs-title function_">resolve_fissures</span>()
                <span class=hljs-keyword>if</span> (new_fissures.<span class=hljs-property>length</span>) <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'fissure'</span>, <span class=hljs-attr>fissures</span>: new_fissures, <span class=hljs-attr>conn</span>: c})
            } <span class=hljs-keyword>else</span> {
                <span class=hljs-keyword>let</span> peer = self.<span class=hljs-property>conns</span>[conn]
                <span class=hljs-keyword>delete</span> self.<span class=hljs-property>conns</span>[conn]

                <span class=hljs-keyword>if</span> (fissure) self.<span class="hljs-title function_">receive</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'fissure'</span>, <span class=hljs-attr>fissure</span>: <span class="hljs-title function_">create_fissure</span>(peer, conn)})
            }
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.forget(conn)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Disconnect the given connection without creating a fissure – we don't need to reconnect with them.. it seems.. if we do, then we need to call <code>disconnect</code> instead, which will create a fissure allowing us to reconnect.</p>
<pre><code class=language-js>alice_antimatter_crdt.forget('connection_to_bob')
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>set</span> = <span class=hljs-function>(<span class=hljs-params>...patches</span>) =&gt;</span> {
            <span class=hljs-keyword>var</span> version = <span class=hljs-string>`<span class=hljs-subst>${self.next_seq++}</span>@<span class=hljs-subst>${self.id}</span>`</span>
            self.<span class="hljs-title function_">receive</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'set'</span>, version, <span class=hljs-attr>parents</span>: {...self.<span class=hljs-property>current_version</span>}, patches})
            <span class=hljs-keyword>return</span> version
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">create_fissure</span>(<span class=hljs-params>peer, conn</span>) {
            <span class=hljs-keyword>let</span> ack_versions = self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>acked_boundary</span>)
            <span class=hljs-keyword>let</span> versions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>).<span class="hljs-title function_">filter</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> !ack_versions[v] || self.<span class=hljs-property>acked_boundary</span>[v]).<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> [v, <span class=hljs-literal>true</span>]))
            <span class=hljs-keyword>return</span> {<span class=hljs-attr>a</span>: self.<span class=hljs-property>id</span>, <span class=hljs-attr>b</span>: peer, conn, versions, <span class=hljs-attr>time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()}
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">resolve_fissures</span>(<span class=hljs-params></span>) {
            <span class=hljs-keyword>let</span> new_fissures = []
            <span class=hljs-keyword>let</span> unfissured = {}

            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(self.<span class=hljs-property>fissures</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>[fk, f]</span>) =&gt;</span> {
                <span class=hljs-keyword>var</span> other_key = f.<span class=hljs-property>b</span> + <span class=hljs-string>':'</span> + f.<span class=hljs-property>a</span> + <span class=hljs-string>':'</span> + f.<span class=hljs-property>conn</span>
                <span class=hljs-keyword>var</span> other = self.<span class=hljs-property>fissures</span>[other_key]

                <span class=hljs-keyword>if</span> (!other &amp;&amp; f.<span class=hljs-property>b</span> == self.<span class=hljs-property>id</span> &amp;&amp; !self.<span class=hljs-property>proto_conns</span>[f.<span class=hljs-property>conn</span>] &amp;&amp; !self.<span class=hljs-property>conns</span>[f.<span class=hljs-property>conn</span>]) {
                    other = {...f, <span class=hljs-attr>a</span>: f.<span class=hljs-property>b</span>, <span class=hljs-attr>b</span>: f.<span class=hljs-property>a</span>}
                    new_fissures.<span class="hljs-title function_">push</span>(self.<span class=hljs-property>fissures</span>[other_key] = other)
                    self.<span class=hljs-property>acks_in_process</span> = {}
                }

                <span class=hljs-keyword>if</span> (other) {
                    <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(f.<span class=hljs-property>versions</span>).<span class=hljs-property>length</span>) {
                        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> v <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(f.<span class=hljs-property>versions</span>)) unfissured[v] = <span class=hljs-literal>true</span>
                        self.<span class=hljs-property>fissures</span>[fk] = {...f, <span class=hljs-attr>versions</span>: {}}
                    }
                    <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(other.<span class=hljs-property>versions</span>).<span class=hljs-property>length</span>) {
                        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> v <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(other.<span class=hljs-property>versions</span>)) unfissured[v] = <span class=hljs-literal>true</span>
                        self.<span class=hljs-property>fissures</span>[other_key] = {...other, <span class=hljs-attr>versions</span>: {}}
                    }
                }
            })

            <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(unfissured).<span class=hljs-property>length</span>) {
                <span class=hljs-keyword>let</span> ack_versions = self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>acked_boundary</span>)
                <span class=hljs-keyword>let</span> unfissured_descendants = self.<span class="hljs-title function_">descendants</span>(unfissured, <span class=hljs-literal>true</span>)
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> un <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(unfissured_descendants)) <span class=hljs-keyword>if</span> (ack_versions[un]) <span class=hljs-keyword>delete</span> ack_versions[un]
                self.<span class=hljs-property>acked_boundary</span> = self.<span class="hljs-title function_">get_leaves</span>(ack_versions)

                <span class=hljs-keyword>let</span> u = self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>unack_boundary</span>)
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> x <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class="hljs-title function_">ancestors</span>(unfissured_descendants))) u[x] = <span class=hljs-literal>true</span>
                self.<span class=hljs-property>unack_boundary</span> = self.<span class="hljs-title function_">get_leaves</span>(u)
            }

            <span class=hljs-keyword>return</span> new_fissures
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">prune</span>(<span class=hljs-params></span>) {
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(self.<span class=hljs-property>fissures</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> {
                <span class=hljs-keyword>var</span> other_key = x[<span class=hljs-number>1</span>].<span class=hljs-property>b</span> + <span class=hljs-string>':'</span> + x[<span class=hljs-number>1</span>].<span class=hljs-property>a</span> + <span class=hljs-string>':'</span> + x[<span class=hljs-number>1</span>].<span class=hljs-property>conn</span>
                <span class=hljs-keyword>var</span> other = self.<span class=hljs-property>fissures</span>[other_key]
                <span class=hljs-keyword>if</span> (other) {
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>fissures</span>[x[<span class=hljs-number>0</span>]]
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>fissures</span>[other_key]
                }
            })

            <span class=hljs-keyword>if</span> (self.<span class=hljs-property>fissure_lifetime</span> != <span class=hljs-literal>null</span>) {
                <span class=hljs-keyword>var</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(self.<span class=hljs-property>fissures</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>[k, f]</span>) =&gt;</span> {
                    <span class=hljs-keyword>if</span> (f.<span class=hljs-property>time</span> == <span class=hljs-literal>null</span>) f.<span class=hljs-property>time</span> = now
                    <span class=hljs-keyword>if</span> (f.<span class=hljs-property>time</span> &lt;= now - self.<span class=hljs-property>fissure_lifetime</span>) {
                        <span class=hljs-keyword>delete</span> self.<span class=hljs-property>fissures</span>[k]
                    }
                })
            }

            <span class=hljs-keyword>var</span> keep_us = {}

            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(self.<span class=hljs-property>fissures</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>f</span> =&gt;</span> {
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(f.<span class=hljs-property>versions</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> keep_us[v] = <span class=hljs-literal>true</span>)
            })

            <span class=hljs-keyword>var</span> acked = self.<span class="hljs-title function_">ancestors</span>(self.<span class=hljs-property>acked_boundary</span>)
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> {
                <span class=hljs-keyword>if</span> (!acked[x] || self.<span class=hljs-property>acked_boundary</span>[x]) keep_us[x] = <span class=hljs-literal>true</span>
            })

            <span class=hljs-keyword>var</span> children = self.<span class="hljs-title function_">get_child_map</span>()

            <span class=hljs-keyword>var</span> to_bubble = {}
            <span class=hljs-keyword>var</span> bubble_tops = {}
            <span class=hljs-keyword>var</span> bubble_bottoms = {}
            
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">mark_bubble</span>(<span class=hljs-params>bottom, top, tag</span>) {
                <span class=hljs-keyword>if</span> (!to_bubble[bottom]) {
                    to_bubble[bottom] = tag
                    <span class=hljs-keyword>if</span> (bottom !== top) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[bottom]).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>p</span> =&gt;</span> <span class="hljs-title function_">mark_bubble</span>(p, top, tag))
                }
            }
            
            <span class=hljs-keyword>var</span> done = {}
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">f</span>(<span class=hljs-params>cur</span>) {
                <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[cur]) <span class=hljs-keyword>return</span>
                <span class=hljs-keyword>if</span> (done[cur]) <span class=hljs-keyword>return</span>
                done[cur] = <span class=hljs-literal>true</span>
                
                <span class=hljs-keyword>if</span> (!to_bubble[cur] || bubble_tops[cur]) {
                    <span class=hljs-keyword>var</span> bubble_top = <span class="hljs-title function_">find_one_bubble</span>(cur)
                    <span class=hljs-keyword>if</span> (bubble_top) {
                        <span class=hljs-keyword>delete</span> to_bubble[cur]
                        <span class="hljs-title function_">mark_bubble</span>(cur, bubble_top, bubble_tops[cur] || cur)
                        bubble_tops[bubble_top] = bubble_tops[cur] || cur
                        bubble_bottoms[bubble_tops[cur] || cur] = bubble_top
                    }
                }

                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[cur]).<span class="hljs-title function_">forEach</span>(f)
            }
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>current_version</span>).<span class="hljs-title function_">forEach</span>(f)

            <span class=hljs-keyword>function</span> <span class="hljs-title function_">find_one_bubble</span>(<span class=hljs-params>cur</span>) {
                <span class=hljs-keyword>var</span> seen = {[cur]: <span class=hljs-literal>true</span>}
                <span class=hljs-keyword>var</span> q = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[cur])
                <span class=hljs-keyword>var</span> expecting = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(q.<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> [x, <span class=hljs-literal>true</span>]))
                <span class=hljs-keyword>while</span> (q.<span class=hljs-property>length</span>) {
                    cur = q.<span class="hljs-title function_">pop</span>()
                    <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[cur]) <span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>
                    <span class=hljs-keyword>if</span> (keep_us[cur]) <span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>
                    <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(children[cur]).<span class="hljs-title function_">every</span>(<span class=hljs-function><span class=hljs-params>c</span> =&gt;</span> seen[c])) {
                        seen[cur] = <span class=hljs-literal>true</span>
                        <span class=hljs-keyword>delete</span> expecting[cur]
                        <span class=hljs-keyword>if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(expecting).<span class=hljs-property>length</span>) <span class=hljs-keyword>return</span> cur
                        
                        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[cur]).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>p</span> =&gt;</span> {
                            q.<span class="hljs-title function_">push</span>(p)
                            expecting[p] = <span class=hljs-literal>true</span>
                        })
                    }
                }
                <span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>
            }

            self.<span class="hljs-title function_">apply_bubbles</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(to_bubble).<span class="hljs-title function_">map</span>(
                <span class=hljs-function>(<span class=hljs-params>[v, bub]</span>) =&gt;</span> [v, [bub, bubble_bottoms[bub]]]
            )))
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">add_full_ack_leaf</span>(<span class=hljs-params>version</span>) {
            <span class=hljs-keyword>var</span> marks = {}
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">f</span>(<span class=hljs-params>v</span>) {
                <span class=hljs-keyword>if</span> (!marks[v]) {
                    marks[v] = <span class=hljs-literal>true</span>
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>unack_boundary</span>[v]
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>acked_boundary</span>[v]
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>acks_in_process</span>[v]
                    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[v]).<span class="hljs-title function_">forEach</span>(f)
                }
            }
            <span class="hljs-title function_">f</span>(version)

            self.<span class=hljs-property>acked_boundary</span>[version] = <span class=hljs-literal>true</span>
            <span class="hljs-title function_">prune</span>(self)
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">check_ack_count</span>(<span class=hljs-params>version</span>) {
            <span class=hljs-keyword>let</span> a = self.<span class=hljs-property>acks_in_process</span>[version]
            <span class=hljs-keyword>if</span> (a?.<span class=hljs-property>count</span> == <span class=hljs-number>0</span>) {
                <span class=hljs-keyword>if</span> (a.<span class=hljs-property>origin</span> != <span class=hljs-literal>null</span>) {
                    <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'ack'</span>, <span class=hljs-attr>seen</span>: <span class=hljs-string>'local'</span>, version, <span class=hljs-attr>conn</span>: a.<span class=hljs-property>origin</span>})
                } <span class=hljs-keyword>else</span> {
                    <span class="hljs-title function_">add_full_ack_leaf</span>(version)
                    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> c <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>conns</span>)) <span class="hljs-title function_">send</span>({<span class=hljs-attr>cmd</span>: <span class=hljs-string>'ack'</span>, <span class=hljs-attr>seen</span>: <span class=hljs-string>'global'</span>, version, <span class=hljs-attr>conn</span>: c})
                }
            }
        }

        <span class=hljs-keyword>return</span> self
    }

    json.<span class=hljs-property>create</span> = <span class=hljs-function><span class=hljs-params>self</span> =&gt;</span> {
        self = self ?? {}     
        self.<span class=hljs-property>S</span> = self.<span class=hljs-property>S</span> ?? <span class=hljs-literal>null</span>
        self.<span class=hljs-property>T</span> = self.<span class=hljs-property>T</span> ?? {}
        self.<span class=hljs-property>current_version</span> = self.<span class=hljs-property>current_version</span> ?? {}

        <span class=hljs-keyword>let</span> <span class="hljs-title function_">is_lit</span> = x =&gt; !x || <span class="hljs-title function_">typeof</span>(x) != <span class=hljs-string>'object'</span> || x.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>
        <span class=hljs-keyword>let</span> <span class="hljs-title function_">get_lit</span> = x =&gt; (x &amp;&amp; <span class="hljs-title function_">typeof</span>(x) == <span class=hljs-string>'object'</span> &amp;&amp; x.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>) ? x.<span class=hljs-property>S</span> : x
        <span class=hljs-keyword>let</span> <span class="hljs-title function_">make_lit</span> = x =&gt; (x &amp;&amp; <span class="hljs-title function_">typeof</span>(x) == <span class=hljs-string>'object'</span>) ? {<span class=hljs-attr>t</span>: <span class=hljs-string>'lit'</span>, <span class=hljs-attr>S</span>: x} : x
            self = self ?? {}
    
</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.disconnect(conn)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>If we detect that a connection has closed, let the antimatter_crdt object know by calling this method with the given connection id – this will create a fissure so we can reconnect with whoever was on the other end of the connection later on.</p>
<pre><code class=language-js>alice_antimatter_crdt.disconnect('connection_to_bob')
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>read</span> = <span class=hljs-function>(<span class=hljs-params>is_anc</span>) =&gt;</span> {
            <span class=hljs-keyword>if</span> (!is_anc) is_anc = <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>

            <span class=hljs-keyword>return</span> <span class="hljs-title function_">rec_read</span>(self.<span class=hljs-property>S</span>)
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">rec_read</span>(<span class=hljs-params>x</span>) {
                <span class=hljs-keyword>if</span> (x &amp;&amp; <span class="hljs-title function_">typeof</span>(x) == <span class=hljs-string>'object'</span>) {
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>) <span class=hljs-keyword>return</span> <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">stringify</span>(x.<span class=hljs-property>S</span>))
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'val'</span>) <span class=hljs-keyword>return</span> <span class="hljs-title function_">rec_read</span>(sequence.<span class="hljs-title function_">get</span>(x.<span class=hljs-property>S</span>, <span class=hljs-number>0</span>, is_anc))
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'obj'</span>) {
                        <span class=hljs-keyword>var</span> o = {}
                        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x.<span class=hljs-property>S</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>[k, v]</span>) =&gt;</span> {
                            <span class=hljs-keyword>var</span> x = <span class="hljs-title function_">rec_read</span>(v)
                            <span class=hljs-keyword>if</span> (x != <span class=hljs-literal>null</span>) o[k] = x
                        })
                        <span class=hljs-keyword>return</span> o
                    }
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'arr'</span>) {
                        <span class=hljs-keyword>var</span> a = []
                        sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, is_anc, <span class=hljs-function>(<span class=hljs-params>node, _, __, ___, ____, deleted</span>) =&gt;</span> {
                            <span class=hljs-keyword>if</span> (!deleted) node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>e</span>) =&gt;</span> a.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">rec_read</span>(e)))
                        }, <span class=hljs-literal>true</span>)
                        <span class=hljs-keyword>return</span> a
                    }
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'str'</span>) {
                        <span class=hljs-keyword>var</span> s = []
                        sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, is_anc, <span class=hljs-function>(<span class=hljs-params>node, _, __, ___, ____, deleted</span>) =&gt;</span> {
                            <span class=hljs-keyword>if</span> (!deleted) s.<span class="hljs-title function_">push</span>(node.<span class=hljs-property>elems</span>)
                        }, <span class=hljs-literal>true</span>)
                        <span class=hljs-keyword>return</span> s.<span class="hljs-title function_">join</span>(<span class=hljs-string>''</span>)
                    }
                    <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                } <span class=hljs-keyword>return</span> x
            }
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.set(...patches)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Modify this antimatter_crdt object by applying the given patches. Each patch looks like <code>{range: '.life.meaning', content: 42}</code>. Calling this method will trigger calling the <code>send</code> callback to let our peers know about this change.</p>
<pre><code class=language-js>antimatter_crdt.set({range: '.life.meaning', content: 42})
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>generate_braid</span> = <span class=hljs-function><span class=hljs-params>versions</span> =&gt;</span> {
            <span class=hljs-keyword>var</span> anc = versions &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(versions).<span class=hljs-property>length</span> ? self.<span class="hljs-title function_">ancestors</span>(versions, <span class=hljs-literal>true</span>) : {}
            <span class=hljs-keyword>var</span> <span class="hljs-title function_">is_anc</span> = x =&gt; anc[x]

            <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>).<span class=hljs-property>length</span> === <span class=hljs-number>0</span>) <span class=hljs-keyword>return</span> []

            <span class=hljs-keyword>return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(self.<span class=hljs-property>version_cache</span>).<span class="hljs-title function_">filter</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> !<span class="hljs-title function_">is_anc</span>(x[<span class=hljs-number>0</span>])).<span class="hljs-title function_">map</span>(<span class=hljs-function>(<span class=hljs-params>[version, set_message]</span>) =&gt;</span> {
                <span class=hljs-keyword>return</span> self.<span class=hljs-property>version_cache</span>[version] = set_message || <span class="hljs-title function_">generate_set_message</span>(version)
            })

            <span class=hljs-keyword>function</span> <span class="hljs-title function_">generate_set_message</span>(<span class=hljs-params>version</span>) {
                <span class=hljs-keyword>if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[version]).<span class=hljs-property>length</span>) {
                    <span class=hljs-keyword>return</span> {
                        version,
                        <span class=hljs-attr>parents</span>: {},
                        <span class=hljs-attr>patches</span>: [{<span class=hljs-attr>range</span>: <span class=hljs-string>''</span>, <span class=hljs-attr>content</span>: self.<span class="hljs-title function_">read</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> v == version)}]
                    }
                }
            
                <span class=hljs-keyword>var</span> <span class="hljs-title function_">is_lit</span> = x =&gt; !x || <span class="hljs-title function_">typeof</span>(x) !== <span class=hljs-string>'object'</span> || x.<span class=hljs-property>t</span> === <span class=hljs-string>'lit'</span>
                <span class=hljs-keyword>var</span> <span class="hljs-title function_">get_lit</span> = x =&gt; (x &amp;&amp; <span class="hljs-title function_">typeof</span>(x) === <span class=hljs-string>'object'</span> &amp;&amp; x.<span class=hljs-property>t</span> === <span class=hljs-string>'lit'</span>) ? x.<span class=hljs-property>S</span> : x
            
                <span class=hljs-keyword>var</span> ancs = self.<span class="hljs-title function_">ancestors</span>({[version]: <span class=hljs-literal>true</span>})
                <span class=hljs-keyword>delete</span> ancs[version]
                <span class=hljs-keyword>var</span> <span class="hljs-title function_">is_anc</span> = x =&gt; ancs[x]
                <span class=hljs-keyword>var</span> path = []
                <span class=hljs-keyword>var</span> patches = []
                <span class=hljs-keyword>var</span> sort_keys = {}
                <span class="hljs-title function_">recurse</span>(self.<span class=hljs-property>S</span>)
                <span class=hljs-keyword>function</span> <span class="hljs-title function_">recurse</span>(<span class=hljs-params>x</span>) {
                    <span class=hljs-keyword>if</span> (<span class="hljs-title function_">is_lit</span>(x)) {
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> === <span class=hljs-string>'val'</span>) {
                        sequence.<span class="hljs-title function_">generate_braid</span>(x.<span class=hljs-property>S</span>, version, is_anc).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>s</span> =&gt;</span> {
                            <span class=hljs-keyword>if</span> (s[<span class=hljs-number>2</span>].<span class=hljs-property>length</span>) {
                                patches.<span class="hljs-title function_">push</span>({<span class=hljs-attr>range</span>: path.<span class="hljs-title function_">join</span>(<span class=hljs-string>''</span>), <span class=hljs-attr>content</span>: s[<span class=hljs-number>2</span>][<span class=hljs-number>0</span>]})
                                <span class=hljs-keyword>if</span> (s[<span class=hljs-number>3</span>]) sort_keys[patches.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>] = s[<span class=hljs-number>3</span>]
                            }
                        })
                        sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, is_anc, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
                            node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">forEach</span>(recurse)
                        })
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> === <span class=hljs-string>'arr'</span>) {
                        sequence.<span class="hljs-title function_">generate_braid</span>(x.<span class=hljs-property>S</span>, version, is_anc).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>s</span> =&gt;</span> {
                            patches.<span class="hljs-title function_">push</span>({<span class=hljs-attr>range</span>: <span class=hljs-string>`<span class=hljs-subst>${path.join(<span class=hljs-string>''</span>)}</span>[<span class=hljs-subst>${s[<span class=hljs-number>0</span>]}</span>:<span class=hljs-subst>${s[<span class=hljs-number>0</span>] + s[<span class=hljs-number>1</span>]}</span>]`</span>, <span class=hljs-attr>content</span>: s[<span class=hljs-number>2</span>]})
                            <span class=hljs-keyword>if</span> (s[<span class=hljs-number>3</span>]) sort_keys[patches.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>] = s[<span class=hljs-number>3</span>]
                        })
                        <span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>
                        sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, is_anc, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
                            node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>e</span> =&gt;</span> {
                                path.<span class="hljs-title function_">push</span>(<span class=hljs-string>`[<span class=hljs-subst>${i++}</span>]`</span>)
                                <span class="hljs-title function_">recurse</span>(e)
                                path.<span class="hljs-title function_">pop</span>()
                            })
                        })
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> === <span class=hljs-string>'obj'</span>) {
                        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x.<span class=hljs-property>S</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>e</span> =&gt;</span> {
                            path.<span class="hljs-title function_">push</span>(<span class=hljs-string>'['</span> + <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">stringify</span>(e[<span class=hljs-number>0</span>]) + <span class=hljs-string>']'</span>)
                            <span class="hljs-title function_">recurse</span>(e[<span class=hljs-number>1</span>])
                            path.<span class="hljs-title function_">pop</span>()
                        })
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> === <span class=hljs-string>'str'</span>) {
                        sequence.<span class="hljs-title function_">generate_braid</span>(x.<span class=hljs-property>S</span>, version, is_anc).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>s</span> =&gt;</span> {
                            patches.<span class="hljs-title function_">push</span>({<span class=hljs-attr>range</span>: <span class=hljs-string>`<span class=hljs-subst>${path.join(<span class=hljs-string>''</span>)}</span>[<span class=hljs-subst>${s[<span class=hljs-number>0</span>]}</span>:<span class=hljs-subst>${s[<span class=hljs-number>0</span>] + s[<span class=hljs-number>1</span>]}</span>]`</span>, <span class=hljs-attr>content</span>: s[<span class=hljs-number>2</span>]})
                            <span class=hljs-keyword>if</span> (s[<span class=hljs-number>3</span>]) sort_keys[patches.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>] = s[<span class=hljs-number>3</span>]
                        })
                    }
                }
            
                <span class=hljs-keyword>return</span> {
                    version,
                    <span class=hljs-attr>parents</span>: {...self.<span class=hljs-property>T</span>[version]},
                    patches,
                    sort_keys
                }
            }
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>antimatter_crdt.marco()</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Initiate sending a <code>marco</code> message to try and establish whether certain versions can be pruned.</p>
<pre><code class=language-js>antimatter_crdt.marco()
</code></pre>
<hr>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>apply_bubbles</span> = <span class=hljs-function><span class=hljs-params>to_bubble</span> =&gt;</span> {
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">recurse</span>(<span class=hljs-params>x</span>) {
                <span class=hljs-keyword>if</span> (<span class="hljs-title function_">is_lit</span>(x)) <span class=hljs-keyword>return</span> x
                <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'val'</span>) {
                    sequence.<span class="hljs-title function_">apply_bubbles</span>(x.<span class=hljs-property>S</span>, to_bubble)
                    sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
                        node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>, <span class=hljs-number>1</span>).<span class="hljs-title function_">map</span>(recurse)
                    }, <span class=hljs-literal>true</span>)
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>S</span>.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span> == <span class=hljs-number>0</span> &amp;&amp; !x.<span class=hljs-property>S</span>.<span class=hljs-property>next</span> &amp;&amp; x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> == <span class=hljs-number>1</span> &amp;&amp; <span class="hljs-title function_">is_lit</span>(x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>[<span class=hljs-number>0</span>])) <span class=hljs-keyword>return</span> x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>[<span class=hljs-number>0</span>]
                    <span class=hljs-keyword>return</span> x
                }
                <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'arr'</span>) {
                    sequence.<span class="hljs-title function_">apply_bubbles</span>(x.<span class=hljs-property>S</span>, to_bubble)
                    sequence.<span class="hljs-title function_">traverse</span>(x.<span class=hljs-property>S</span>, <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
                        node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">map</span>(recurse)
                    }, <span class=hljs-literal>true</span>)
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>S</span>.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span> == <span class=hljs-number>0</span> &amp;&amp; !x.<span class=hljs-property>S</span>.<span class=hljs-property>next</span> &amp;&amp; x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>.<span class="hljs-title function_">every</span>(is_lit) &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(x.<span class=hljs-property>S</span>.<span class=hljs-property>deleted_by</span>).<span class=hljs-property>length</span>) <span class=hljs-keyword>return</span> {<span class=hljs-attr>t</span>: <span class=hljs-string>'lit'</span>, <span class=hljs-attr>S</span>: x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>.<span class="hljs-title function_">map</span>(get_lit)}
                    <span class=hljs-keyword>return</span> x
                }
                <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'obj'</span>) {
                    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x.<span class=hljs-property>S</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>e</span> =&gt;</span> {
                        <span class=hljs-keyword>var</span> y = x.<span class=hljs-property>S</span>[e[<span class=hljs-number>0</span>]] = <span class="hljs-title function_">recurse</span>(e[<span class=hljs-number>1</span>])
                        <span class=hljs-keyword>if</span> (y == <span class=hljs-literal>null</span>) <span class=hljs-keyword>delete</span> x.<span class=hljs-property>S</span>[e[<span class=hljs-number>0</span>]]
                    })
                    <span class=hljs-keyword>if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(x.<span class=hljs-property>S</span>).<span class="hljs-title function_">every</span>(is_lit)) {
                        <span class=hljs-keyword>var</span> o = {}
                        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x.<span class=hljs-property>S</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>e</span> =&gt;</span> o[e[<span class=hljs-number>0</span>]] = <span class="hljs-title function_">get_lit</span>(e[<span class=hljs-number>1</span>]))
                        <span class=hljs-keyword>return</span> {<span class=hljs-attr>t</span>: <span class=hljs-string>'lit'</span>, <span class=hljs-attr>S</span>: o}
                    }
                    <span class=hljs-keyword>return</span> x
                }
                <span class=hljs-keyword>if</span> (x.<span class=hljs-property>t</span> == <span class=hljs-string>'str'</span>) {
                    sequence.<span class="hljs-title function_">apply_bubbles</span>(x.<span class=hljs-property>S</span>, to_bubble)
                    <span class=hljs-keyword>if</span> (x.<span class=hljs-property>S</span>.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span> == <span class=hljs-number>0</span> &amp;&amp; !x.<span class=hljs-property>S</span>.<span class=hljs-property>next</span> &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(x.<span class=hljs-property>S</span>.<span class=hljs-property>deleted_by</span>).<span class=hljs-property>length</span>) <span class=hljs-keyword>return</span> x.<span class=hljs-property>S</span>.<span class=hljs-property>elems</span>
                    <span class=hljs-keyword>return</span> x
                }
            }
            self.<span class=hljs-property>S</span> = <span class="hljs-title function_">recurse</span>(self.<span class=hljs-property>S</span>)

            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(to_bubble).<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>[version, bubble]</span>) =&gt;</span> {
                <span class=hljs-keyword>if</span> (version === bubble[<span class=hljs-number>1</span>])
                    self.<span class=hljs-property>T</span>[bubble[<span class=hljs-number>0</span>]] = self.<span class=hljs-property>T</span>[bubble[<span class=hljs-number>1</span>]]
                <span class=hljs-keyword>if</span> (version !== bubble[<span class=hljs-number>0</span>]) {
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>T</span>[version]
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>version_cache</span>[version]
                } <span class=hljs-keyword>else</span> self.<span class=hljs-property>version_cache</span>[version] = <span class=hljs-literal>null</span>
            })

            <span class=hljs-keyword>var</span> leaves = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>current_version</span>)
            <span class=hljs-keyword>var</span> acked_boundary = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>acked_boundary</span>)
            <span class=hljs-keyword>var</span> fiss = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>fissures</span>)
            <span class=hljs-keyword>if</span> (leaves.<span class=hljs-property>length</span> == <span class=hljs-number>1</span> &amp;&amp; acked_boundary.<span class=hljs-property>length</span> == <span class=hljs-number>1</span>
                &amp;&amp; leaves[<span class=hljs-number>0</span>] == acked_boundary[<span class=hljs-number>0</span>] &amp;&amp; fiss.<span class=hljs-property>length</span> == <span class=hljs-number>0</span>) {
                self.<span class=hljs-property>T</span> = { [leaves[<span class=hljs-number>0</span>]]: {} }
                self.<span class=hljs-property>S</span> = <span class="hljs-title function_">make_lit</span>(self.<span class="hljs-title function_">read</span>())
            }
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>create_json_crdt([init])</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Create a new <code>json_crdt</code> object (or start with <code>init</code>, and add stuff to that).</p>
<pre><code class=language-js>var json_crdt = create_json_crdt()
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>add_version</span> = <span class=hljs-function>(<span class=hljs-params>version, parents, patches, sort_keys</span>) =&gt;</span> {
            <span class=hljs-keyword>if</span> (self.<span class=hljs-property>T</span>[version]) <span class=hljs-keyword>return</span>

            self.<span class=hljs-property>T</span>[version] = {...parents}

            self.<span class=hljs-property>version_cache</span>[version] = <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">stringify</span>({
                version, parents, patches, sort_keys
            }))

            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(parents).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>k</span> =&gt;</span> {
                <span class=hljs-keyword>if</span> (self.<span class=hljs-property>current_version</span>[k])
                    <span class=hljs-keyword>delete</span> self.<span class=hljs-property>current_version</span>[k]
            })
            self.<span class=hljs-property>current_version</span>[version] = <span class=hljs-literal>true</span>
            
            <span class=hljs-keyword>if</span> (!sort_keys) sort_keys = {}
            
            <span class=hljs-keyword>if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(parents).<span class=hljs-property>length</span>) {
                <span class=hljs-keyword>var</span> parse = self.<span class="hljs-title function_">parse_patch</span>(patches[<span class=hljs-number>0</span>])
                self.<span class=hljs-property>S</span> = <span class="hljs-title function_">make_lit</span>(parse.<span class=hljs-property>value</span>)
                <span class=hljs-keyword>return</span> patches
            }
            
            <span class=hljs-keyword>let</span> is_anc
            <span class=hljs-keyword>if</span> (parents == self.<span class=hljs-property>current_version</span>) {
                is_anc = <span class=hljs-function><span class=hljs-params>_version</span> =&gt;</span> _version != version
            } <span class=hljs-keyword>else</span> {
                <span class=hljs-keyword>let</span> ancs = self.<span class="hljs-title function_">ancestors</span>(parents)
                is_anc = <span class=hljs-function><span class=hljs-params>_version</span> =&gt;</span> ancs[_version]
            }
            
            <span class=hljs-keyword>var</span> rebased_patches = []
            patches.<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>patch, i</span>) =&gt;</span> {
                <span class=hljs-keyword>var</span> sort_key = sort_keys[i]
                <span class=hljs-keyword>var</span> parse = self.<span class="hljs-title function_">parse_patch</span>(patch)
                <span class=hljs-keyword>var</span> cur = <span class="hljs-title function_">resolve_path</span>(parse)
                <span class=hljs-keyword>if</span> (!parse.<span class=hljs-property>slice</span>) {
                    <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> != <span class=hljs-string>'val'</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                    <span class=hljs-keyword>var</span> len = sequence.<span class="hljs-title function_">length</span>(cur.<span class=hljs-property>S</span>, is_anc)
                    sequence.<span class="hljs-title function_">add_version</span>(cur.<span class=hljs-property>S</span>, version, [[<span class=hljs-number>0</span>, len, [parse.<span class=hljs-property>delete</span> ? <span class=hljs-literal>null</span> : <span class="hljs-title function_">make_lit</span>(parse.<span class=hljs-property>value</span>)], sort_key]], is_anc)
                    rebased_patches.<span class="hljs-title function_">push</span>(patch)
                } <span class=hljs-keyword>else</span> {
                    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> parse.<span class=hljs-property>value</span> === <span class=hljs-string>'string'</span> &amp;&amp; cur.<span class=hljs-property>t</span> !== <span class=hljs-string>'str'</span>)
                        <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>`Cannot splice string <span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.stringify(parse.value)}</span> into non-string`</span>)
                    <span class=hljs-keyword>if</span> (parse.<span class=hljs-property>value</span> <span class=hljs-keyword>instanceof</span> <span class="hljs-title class_">Array</span> &amp;&amp; cur.<span class=hljs-property>t</span> !== <span class=hljs-string>'arr'</span>)
                        <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>`Cannot splice array <span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.stringify(parse.value)}</span> into non-array`</span>)
                    <span class=hljs-keyword>if</span> (parse.<span class=hljs-property>value</span> <span class=hljs-keyword>instanceof</span> <span class="hljs-title class_">Array</span>)
                        parse.<span class=hljs-property>value</span> = parse.<span class=hljs-property>value</span>.<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> <span class="hljs-title function_">make_lit</span>(x))

                    <span class=hljs-keyword>var</span> r0 = parse.<span class=hljs-property>slice</span>[<span class=hljs-number>0</span>]
                    <span class=hljs-keyword>var</span> r1 = parse.<span class=hljs-property>slice</span>[<span class=hljs-number>1</span>]
                    <span class=hljs-keyword>if</span> (r0 &lt; <span class=hljs-number>0</span> || <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(r0, -<span class=hljs-number>0</span>) || r1 &lt; <span class=hljs-number>0</span> || <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(r1, -<span class=hljs-number>0</span>)) {
                        <span class=hljs-keyword>let</span> len = sequence.<span class="hljs-title function_">length</span>(cur.<span class=hljs-property>S</span>, is_anc)
                        <span class=hljs-keyword>if</span> (r0 &lt; <span class=hljs-number>0</span> || <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(r0, -<span class=hljs-number>0</span>)) r0 = len + r0
                        <span class=hljs-keyword>if</span> (r1 &lt; <span class=hljs-number>0</span> || <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(r1, -<span class=hljs-number>0</span>)) r1 = len + r1
                    }

                    <span class=hljs-keyword>var</span> rebased_splices = sequence.<span class="hljs-title function_">add_version</span>(cur.<span class=hljs-property>S</span>, version, [[r0, r1 - r0, parse.<span class=hljs-property>value</span>, sort_key]], is_anc)
                    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> rebased_splice <span class=hljs-keyword>of</span> rebased_splices) rebased_patches.<span class="hljs-title function_">push</span>({
                        <span class=hljs-attr>range</span>: <span class=hljs-string>`<span class=hljs-subst>${parse.path.map(x =&gt; <span class=hljs-string>`[<span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.stringify(x)}</span>]`</span>).join(<span class=hljs-string>''</span>)}</span>[<span class=hljs-subst>${rebased_splice[<span class=hljs-number>0</span>]}</span>:<span class=hljs-subst>${rebased_splice[<span class=hljs-number>0</span>] + rebased_splice[<span class=hljs-number>1</span>]}</span>]`</span>,
                        <span class=hljs-attr>content</span>: rebased_splice[<span class=hljs-number>2</span>]
                    })
                }
            })

            <span class=hljs-keyword>function</span> <span class="hljs-title function_">resolve_path</span>(<span class=hljs-params>parse</span>) {
                <span class=hljs-keyword>var</span> cur = self.<span class=hljs-property>S</span>
                <span class=hljs-keyword>if</span> (!cur || <span class="hljs-title function_">typeof</span>(cur) != <span class=hljs-string>'object'</span> || cur.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>)
                    cur = self.<span class=hljs-property>S</span> = {<span class=hljs-attr>t</span>: <span class=hljs-string>'val'</span>, <span class=hljs-attr>S</span>: sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, [cur])}
                <span class=hljs-keyword>var</span> prev_S = <span class=hljs-literal>null</span>
                <span class=hljs-keyword>var</span> prev_i = <span class=hljs-number>0</span>
                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i=<span class=hljs-number>0</span>; i&lt;parse.<span class=hljs-property>path</span>.<span class=hljs-property>length</span>; i++) {
                    <span class=hljs-keyword>var</span> key = parse.<span class=hljs-property>path</span>[i]
                    <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'val'</span>) cur = sequence.<span class="hljs-title function_">get</span>(prev_S = cur.<span class=hljs-property>S</span>, prev_i = <span class=hljs-number>0</span>, is_anc)
                    <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>) {
                        <span class=hljs-keyword>var</span> new_cur = {}
                        <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>S</span> <span class=hljs-keyword>instanceof</span> <span class="hljs-title class_">Array</span>) {
                            new_cur.<span class=hljs-property>t</span> = <span class=hljs-string>'arr'</span>
                            new_cur.<span class=hljs-property>S</span> = sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, cur.<span class=hljs-property>S</span>.<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> <span class="hljs-title function_">make_lit</span>(x)))
                        } <span class=hljs-keyword>else</span> {
                            <span class=hljs-keyword>if</span> (<span class="hljs-title function_">typeof</span>(cur.<span class=hljs-property>S</span>) != <span class=hljs-string>'object'</span>) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                            new_cur.<span class=hljs-property>t</span> = <span class=hljs-string>'obj'</span>
                            new_cur.<span class=hljs-property>S</span> = {}
                            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(cur.<span class=hljs-property>S</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>e</span> =&gt;</span> new_cur.<span class=hljs-property>S</span>[e[<span class=hljs-number>0</span>]] = <span class="hljs-title function_">make_lit</span>(e[<span class=hljs-number>1</span>]))
                        }
                        cur = new_cur
                        sequence.<span class="hljs-title function_">set</span>(prev_S, prev_i, cur, is_anc)
                    }
                    <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'obj'</span>) {
                        <span class=hljs-keyword>let</span> x = cur.<span class=hljs-property>S</span>[key]
                        <span class=hljs-keyword>if</span> (!x || <span class="hljs-title function_">typeof</span>(x) != <span class=hljs-string>'object'</span> || x.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>)
                            x = cur.<span class=hljs-property>S</span>[key] = {<span class=hljs-attr>t</span>: <span class=hljs-string>'val'</span>, <span class=hljs-attr>S</span>: sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, [x == <span class=hljs-literal>null</span> ? <span class=hljs-literal>null</span> : x])}
                        cur = x
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (i == parse.<span class=hljs-property>path</span>.<span class=hljs-property>length</span> - <span class=hljs-number>1</span> &amp;&amp; !parse.<span class=hljs-property>slice</span>) {
                        parse.<span class=hljs-property>slice</span> = [key, key + <span class=hljs-number>1</span>]
                        parse.<span class=hljs-property>value</span> = (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'str'</span>) ? parse.<span class=hljs-property>value</span> : [parse.<span class=hljs-property>value</span>]
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'arr'</span>) {
                        cur = sequence.<span class="hljs-title function_">get</span>(prev_S = cur.<span class=hljs-property>S</span>, prev_i = key, is_anc)
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                }
                <span class=hljs-keyword>if</span> (parse.<span class=hljs-property>slice</span>) {
                    <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'val'</span>) cur = sequence.<span class="hljs-title function_">get</span>(prev_S = cur.<span class=hljs-property>S</span>, prev_i = <span class=hljs-number>0</span>, is_anc)
                    <span class=hljs-keyword>if</span> (<span class="hljs-title function_">typeof</span>(cur) == <span class=hljs-string>'string'</span>) {
                        cur = {<span class=hljs-attr>t</span>: <span class=hljs-string>'str'</span>, <span class=hljs-attr>S</span>: sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, cur)}
                        sequence.<span class="hljs-title function_">set</span>(prev_S, prev_i, cur, is_anc)
                    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (cur.<span class=hljs-property>t</span> == <span class=hljs-string>'lit'</span>) {
                        <span class=hljs-keyword>if</span> (!(cur.<span class=hljs-property>S</span> <span class=hljs-keyword>instanceof</span> <span class="hljs-title class_">Array</span>)) <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>'bad'</span>)
                        cur = {<span class=hljs-attr>t</span>: <span class=hljs-string>'arr'</span>, <span class=hljs-attr>S</span>: sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, cur.<span class=hljs-property>S</span>.<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> <span class="hljs-title function_">make_lit</span>(x)))}
                        sequence.<span class="hljs-title function_">set</span>(prev_S, prev_i, cur, is_anc)
                    }
                }
                <span class=hljs-keyword>return</span> cur
            }

            <span class=hljs-keyword>return</span> rebased_patches
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.read()</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Returns an instance of the <code>json</code> object represented by this json_crdt data-structure.</p>
<pre><code class=language-js>console.log(json_crdt.read())
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>get_child_map</span> = <span class=hljs-function>() =&gt;</span> {
            <span class=hljs-keyword>let</span> children = {}
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(self.<span class=hljs-property>T</span>).<span class="hljs-title function_">forEach</span>(<span class=hljs-function>(<span class=hljs-params>[v, parents]</span>) =&gt;</span> {
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(parents).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>parent</span> =&gt;</span> {
                    <span class=hljs-keyword>if</span> (!children[parent]) children[parent] = {}
                    children[parent][v] = <span class=hljs-literal>true</span>
                })
            })
            <span class=hljs-keyword>return</span> children
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.generate_braid(versions)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Returns an array of <code>set</code> messages that each look like this: <code>{version, parents, patches, sort_keys}</code>, such that if we pass all these messages to <code>antimatter_crdt.receive()</code>, we'll reconstruct the data in this <code>json_crdt</code> datastructure, assuming the recipient already has the given <code>versions</code> (which is represented as an object where each key is a version, and each value is <code>true</code>).</p>
<pre><code class=language-js>json_crdt.generate_braid({alice2: true, bob3: true})
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>ancestors</span> = <span class=hljs-function>(<span class=hljs-params>versions, ignore_nonexistent</span>) =&gt;</span> {
            <span class=hljs-keyword>var</span> result = {}
            <span class=hljs-keyword>var</span> stack = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(versions)

            <span class=hljs-keyword>while</span> (stack.<span class=hljs-property>length</span> &gt; <span class=hljs-number>0</span>) {
                <span class=hljs-keyword>var</span> version = stack.<span class="hljs-title function_">pop</span>()

                <span class=hljs-keyword>if</span> (result[version]) <span class=hljs-keyword>continue</span>

                <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[version]) {
                    <span class=hljs-keyword>if</span> (ignore_nonexistent) <span class=hljs-keyword>continue</span>
                    <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>`The version <span class=hljs-subst>${version}</span> no existo`</span>)
                }

                result[version] = <span class=hljs-literal>true</span>;
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[version]).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>childVersion</span> =&gt;</span> {
                    <span class=hljs-keyword>if</span> (!result[childVersion]) {
                        stack.<span class="hljs-title function_">push</span>(childVersion)
                    }
                })
            }

            <span class=hljs-keyword>return</span> result
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.apply_bubbles(to_bubble)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>This method helps prune away meta data and compress stuff when we have determined that certain versions can be renamed to other versions – these renamings are expressed in <code>to_bubble</code>, where keys are versions and values are "bubbles", each bubble represented with an array of two elements, the first element is the "bottom" of the bubble, and the second element is the "top" of the bubble; "bottom" and "top" make sense when viewing versions in a directed graph with the oldest version(s) at the top, and each version pointing up to it's parents. A bubble is then a set of versions where the only arrows leaving the bubble upward are from the "top" version, and the only arrows leaving the bubble downward are from the "bottom" version. This method effectively combines all the versions in a bubble into a single version, and may allow the data structure to be compressed, since now we don't need to distinguish between certain versions that we used to need to.</p>
<pre><code class=language-js>json_crdt.apply_bubbles({alice4: ['bob5', 'alice4'], bob5: ['bob5', 'alice4']})
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>descendants</span> = <span class=hljs-function>(<span class=hljs-params>versions, ignore_nonexistent</span>) =&gt;</span> {
            <span class=hljs-keyword>let</span> children = self.<span class="hljs-title function_">get_child_map</span>()
            <span class=hljs-keyword>var</span> result = {}
            <span class=hljs-keyword>function</span> <span class="hljs-title function_">recurse</span>(<span class=hljs-params>version</span>) {
                <span class=hljs-keyword>if</span> (result[version]) <span class=hljs-keyword>return</span>
                <span class=hljs-keyword>if</span> (!self.<span class=hljs-property>T</span>[version]) {
                    <span class=hljs-keyword>if</span> (ignore_nonexistent) <span class=hljs-keyword>return</span>
                    <span class=hljs-keyword>throw</span> <span class="hljs-title class_">Error</span>(<span class=hljs-string>`The version <span class=hljs-subst>${version}</span> no existo`</span>)
                }
                result[version] = <span class=hljs-literal>true</span>
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(children[version] ?? {}).<span class="hljs-title function_">forEach</span>(recurse)
            }
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(versions).<span class="hljs-title function_">forEach</span>(recurse)
            <span class=hljs-keyword>return</span> result
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.add_version(version, parents, patches[, sort_keys])</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>The main method for modifying a <code>json_crdt</code> data structure.</p>
<ul>
<li><code>version</code>: Unique string associated with this edit.</li>
<li><code>parents</code>: A set of versions that this version is aware of, represented as a map with versions as keys, and values of <code>true</code>.</li>
<li><code>patches</code>: An array of patches, where each patch is an object like this <code>{range: '.life.meaning', content: 42}</code>.</li>
<li><code>sort_keys</code>: (optional) An object where each key is an index, and the value is a sort_key to use with the patch at the given index in the <code>patches</code> array – a sort_key overrides the version for a patch for the purposes of sorting. This can be useful after doing some pruning.</li>
</ul>
<pre><code class=language-js>json_crdt.add_version('alice6',
    {alice5: true, bob7: true},
    [{range: '.a.b', content: 'c'}])
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>get_leaves</span> = <span class=hljs-function><span class=hljs-params>versions</span> =&gt;</span> {
            <span class=hljs-keyword>var</span> leaves = {...versions}
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(versions).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> {
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(self.<span class=hljs-property>T</span>[v]).<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>p</span> =&gt;</span> <span class=hljs-keyword>delete</span> leaves[p])
            })
            <span class=hljs-keyword>return</span> leaves
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.get_child_map()</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Returns a map where each key is a version, and each value is a set of child versions, represented as a map with versions as keys, and values of <code>true</code>.</p>
<pre><code class=language-js>json_crdt.get_child_map()
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>parse_patch</span> = <span class=hljs-function><span class=hljs-params>patch</span> =&gt;</span> {
            <span class=hljs-keyword>let</span> x = self.<span class="hljs-title function_">parse_json_path</span>(patch.<span class=hljs-property>range</span>)
            x.<span class=hljs-property>value</span> = patch.<span class=hljs-property>content</span>
            <span class=hljs-keyword>return</span> x
        }

</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.ancestors(versions, ignore_nonexistent=false)</h1><div style=display:flex;align-items:start><div style=box-sizing:border-box;width:50%;padding-left:10px;padding-right:10px><p>Gather <code>versions</code> and all their ancestors into a set. <code>versions</code> is a set of versions, i.e. a map with version-keys and values of true – we'll basically return a larger set. If <code>ignore_nonexistent</code> is <code>true</code>, then we won't throw an exception if we encounter a version that we don't have in our datastructure.</p>
<pre><code class=language-js>json_crdt.ancestors({alice12: true, bob10: true})
</code></pre>
</div><pre style=box-sizing:border-box;padding:16px;margin:0px;background:rgb(242,242,242);width:50%;--darkreader-inline-bgcolor:#1f2223;--darkreader-inline-bgimage:none data-darkreader-inline-bgcolor data-darkreader-inline-bgimage>        self.<span class=hljs-property>parse_json_path</span> = <span class=hljs-function><span class=hljs-params>json_path</span> =&gt;</span> {
            <span class=hljs-keyword>var</span> ret = { path : [] }
            <span class=hljs-keyword>var</span> re = <span class=hljs-regexp>/^(delete)\s+|\.?([^\.\[ =]+)|\[((\-?\d+)(:\-?\d+)?|"(\\"|[^"])*")\]/g</span>
            <span class=hljs-keyword>var</span> m
            <span class=hljs-keyword>while</span> (m = re.<span class="hljs-title function_">exec</span>(json_path)) {
                <span class=hljs-keyword>if</span> (m[<span class=hljs-number>1</span>]) ret.<span class=hljs-property>delete</span> = <span class=hljs-literal>true</span>
                <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (m[<span class=hljs-number>2</span>]) ret.<span class=hljs-property>path</span>.<span class="hljs-title function_">push</span>(m[<span class=hljs-number>2</span>])
                <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (m[<span class=hljs-number>3</span>] &amp;&amp; m[<span class=hljs-number>5</span>]) ret.<span class=hljs-property>slice</span> = [<span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">parse</span>(m[<span class=hljs-number>4</span>]), <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">parse</span>(m[<span class=hljs-number>5</span>].<span class="hljs-title function_">substr</span>(<span class=hljs-number>1</span>))]
                <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (m[<span class=hljs-number>3</span>]) ret.<span class=hljs-property>path</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">parse</span>(m[<span class=hljs-number>3</span>]))
            }
            <span class=hljs-keyword>return</span> ret
        }

        <span class=hljs-keyword>return</span> self
    }

    sequence.<span class=hljs-property>create_node</span> = <span class=hljs-function>(<span class=hljs-params>version, elems, end_cap, sort_key</span>) =&gt;</span> ({
        version,
        sort_key,
        elems,
        end_cap,
        deleted_by : {},
        nexts : [],
        next : <span class=hljs-literal>null</span>
    })

    sequence.<span class=hljs-property>generate_braid</span> = <span class=hljs-function>(<span class=hljs-params>S, version, is_anc</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> splices = []

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">add_ins</span>(<span class=hljs-params>offset, ins, sort_key, end_cap</span>) {
            <span class=hljs-keyword>if</span> (<span class="hljs-title function_">typeof</span>(ins) !== <span class=hljs-string>'string'</span>)
                ins = ins.<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> <span class="hljs-title function_">read_raw</span>(x, <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>false</span>))
            <span class=hljs-keyword>if</span> (splices.<span class=hljs-property>length</span> &gt; <span class=hljs-number>0</span>) {
                <span class=hljs-keyword>var</span> prev = splices[splices.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>]
                <span class=hljs-keyword>if</span> (prev[<span class=hljs-number>0</span>] + prev[<span class=hljs-number>1</span>] === offset &amp;&amp; !end_cap &amp;&amp; (prev[<span class=hljs-number>4</span>] === <span class=hljs-string>'i'</span> || (prev[<span class=hljs-number>4</span>] === <span class=hljs-string>'r'</span> &amp;&amp; prev[<span class=hljs-number>1</span>] === <span class=hljs-number>0</span>))) {
                    prev[<span class=hljs-number>2</span>] = prev[<span class=hljs-number>2</span>].<span class="hljs-title function_">concat</span>(ins)
                    <span class=hljs-keyword>return</span>
                }
            }
            splices.<span class="hljs-title function_">push</span>([offset, <span class=hljs-number>0</span>, ins, sort_key, end_cap ? <span class=hljs-string>'r'</span> : <span class=hljs-string>'i'</span>])
        }

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">add_del</span>(<span class=hljs-params>offset, del, ins</span>) {
            <span class=hljs-keyword>if</span> (splices.<span class=hljs-property>length</span> &gt; <span class=hljs-number>0</span>) {
                <span class=hljs-keyword>var</span> prev = splices[splices.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>]
                <span class=hljs-keyword>if</span> (prev[<span class=hljs-number>0</span>] + prev[<span class=hljs-number>1</span>] === offset &amp;&amp; prev[<span class=hljs-number>4</span>] !== <span class=hljs-string>'i'</span>) {
                    prev[<span class=hljs-number>1</span>] += del
                    <span class=hljs-keyword>return</span>
                }
            }
            splices.<span class="hljs-title function_">push</span>([offset, del, ins, <span class=hljs-literal>null</span>, <span class=hljs-string>'d'</span>])
        }
        
        <span class=hljs-keyword>var</span> offset = <span class=hljs-number>0</span>
        <span class=hljs-keyword>function</span> <span class="hljs-title function_">helper</span>(<span class=hljs-params>node, _version, end_cap</span>) {
            <span class=hljs-keyword>if</span> (_version === version) {
                <span class="hljs-title function_">add_ins</span>(offset, node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>), node.<span class=hljs-property>sort_key</span>, end_cap)
            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (node.<span class=hljs-property>deleted_by</span>[version] &amp;&amp; node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> &gt; <span class=hljs-number>0</span>) {
                <span class="hljs-title function_">add_del</span>(offset, node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>, node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>))
            }
            
            <span class=hljs-keyword>if</span> ((!_version || <span class="hljs-title function_">is_anc</span>(_version)) &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">some</span>(is_anc)) {
                offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
            }
            
            node.<span class=hljs-property>nexts</span>.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class="hljs-title function_">helper</span>(next, next.<span class=hljs-property>version</span>, node.<span class=hljs-property>end_cap</span>))
            <span class=hljs-keyword>if</span> (node.<span class=hljs-property>next</span>) <span class="hljs-title function_">helper</span>(node.<span class=hljs-property>next</span>, _version)
        }
        <span class="hljs-title function_">helper</span>(S, <span class=hljs-literal>null</span>)
        splices.<span class="hljs-title function_">forEach</span>(<span class=hljs-function><span class=hljs-params>s</span> =&gt;</span> {
            <span class=hljs-comment>// if we have replaces with 0 deletes,</span>
            <span class=hljs-comment>// make them have at least 1 delete..</span>
            <span class=hljs-comment>// this can happen when there are multiple replaces of the same text,</span>
            <span class=hljs-comment>// and our code above will associate those deletes with only one of them</span>
            <span class=hljs-keyword>if</span> (s[<span class=hljs-number>4</span>] === <span class=hljs-string>'r'</span> &amp;&amp; s[<span class=hljs-number>1</span>] === <span class=hljs-number>0</span>) s[<span class=hljs-number>1</span>] = <span class=hljs-number>1</span>
        })
        <span class=hljs-keyword>return</span> splices
    }

    sequence.<span class=hljs-property>apply_bubbles</span> = <span class=hljs-function>(<span class=hljs-params>S, to_bubble</span>) =&gt;</span> {

        sequence.<span class="hljs-title function_">traverse</span>(S, <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
            <span class=hljs-keyword>if</span> (to_bubble[node.<span class=hljs-property>version</span>] &amp;&amp; to_bubble[node.<span class=hljs-property>version</span>][<span class=hljs-number>0</span>] != node.<span class=hljs-property>version</span>) {
                <span class=hljs-keyword>if</span> (!node.<span class=hljs-property>sort_key</span>) node.<span class=hljs-property>sort_key</span> = node.<span class=hljs-property>version</span>
                node.<span class=hljs-property>version</span> = to_bubble[node.<span class=hljs-property>version</span>][<span class=hljs-number>0</span>]
            }

            <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> x <span class=hljs-keyword>of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>)) {
                <span class=hljs-keyword>if</span> (to_bubble[x]) {
                    <span class=hljs-keyword>delete</span> node.<span class=hljs-property>deleted_by</span>[x]
                    node.<span class=hljs-property>deleted_by</span>[to_bubble[x][<span class=hljs-number>0</span>]] = <span class=hljs-literal>true</span>
                }
            }
        }, <span class=hljs-literal>true</span>)

        <span class=hljs-keyword>function</span> <span class="hljs-title function_">set_nnnext</span>(<span class=hljs-params>node, next</span>) {
            <span class=hljs-keyword>while</span> (node.<span class=hljs-property>next</span>) node = node.<span class=hljs-property>next</span>
            node.<span class=hljs-property>next</span> = next
        }

        <span class="hljs-title function_">do_line</span>(S, S.<span class=hljs-property>version</span>)
        <span class=hljs-keyword>function</span> <span class="hljs-title function_">do_line</span>(<span class=hljs-params>node, version</span>) {
            <span class=hljs-keyword>var</span> prev = <span class=hljs-literal>null</span>
            <span class=hljs-keyword>while</span> (node) {
                <span class=hljs-keyword>if</span> (node.<span class=hljs-property>nexts</span>[<span class=hljs-number>0</span>] &amp;&amp; node.<span class=hljs-property>nexts</span>[<span class=hljs-number>0</span>].<span class=hljs-property>version</span> == version) {
                    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; node.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span>; i++) {
                        <span class=hljs-keyword>delete</span> node.<span class=hljs-property>nexts</span>[i].<span class=hljs-property>version</span>
                        <span class=hljs-keyword>delete</span> node.<span class=hljs-property>nexts</span>[i].<span class=hljs-property>sort_key</span>
                        <span class="hljs-title function_">set_nnnext</span>(node.<span class=hljs-property>nexts</span>[i], i + <span class=hljs-number>1</span> &lt; node.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span> ? node.<span class=hljs-property>nexts</span>[i + <span class=hljs-number>1</span>] : node.<span class=hljs-property>next</span>)
                    }
                    node.<span class=hljs-property>next</span> = node.<span class=hljs-property>nexts</span>[<span class=hljs-number>0</span>]
                    node.<span class=hljs-property>nexts</span> = []
                }

                <span class=hljs-keyword>if</span> (node.<span class=hljs-property>deleted_by</span>[version]) {
                    node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>)
                    node.<span class=hljs-property>deleted_by</span> = {}
                    <span class=hljs-keyword>if</span> (prev) { node = prev; <span class=hljs-keyword>continue</span> }
                }

                <span class=hljs-keyword>var</span> next = node.<span class=hljs-property>next</span>

                <span class=hljs-keyword>if</span> (!node.<span class=hljs-property>nexts</span>.<span class=hljs-property>length</span> &amp;&amp; next &amp;&amp; (!node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> || !next.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> || (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">every</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> next.<span class=hljs-property>deleted_by</span>[x]) &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(next.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">every</span>(<span class=hljs-function><span class=hljs-params>x</span> =&gt;</span> node.<span class=hljs-property>deleted_by</span>[x])))) {
                    <span class=hljs-keyword>if</span> (!node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>) node.<span class=hljs-property>deleted_by</span> = next.<span class=hljs-property>deleted_by</span>
                    node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">concat</span>(next.<span class=hljs-property>elems</span>)
                    node.<span class=hljs-property>end_cap</span> = next.<span class=hljs-property>end_cap</span>
                    node.<span class=hljs-property>nexts</span> = next.<span class=hljs-property>nexts</span>
                    node.<span class=hljs-property>next</span> = next.<span class=hljs-property>next</span>
                    <span class=hljs-keyword>continue</span>
                }

                <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> n <span class=hljs-keyword>of</span> node.<span class=hljs-property>nexts</span>) <span class="hljs-title function_">do_line</span>(n, n.<span class=hljs-property>version</span>)

                prev = node
                node = next
            }
        }
    }

    sequence.<span class=hljs-property>get</span> = <span class=hljs-function>(<span class=hljs-params>S, i, is_anc</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> ret = <span class=hljs-literal>null</span>
        <span class=hljs-keyword>var</span> offset = <span class=hljs-number>0</span>
        sequence.<span class="hljs-title function_">traverse</span>(S, is_anc ? is_anc : <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function>(<span class=hljs-params>node</span>) =&gt;</span> {
            <span class=hljs-keyword>if</span> (i - offset &lt; node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>) {
                ret = node.<span class=hljs-property>elems</span>[i - offset]
                <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
            }
            offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
        })
        <span class=hljs-keyword>return</span> ret
    }

    sequence.<span class=hljs-property>set</span> = <span class=hljs-function>(<span class=hljs-params>S, i, v, is_anc</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> offset = <span class=hljs-number>0</span>
        sequence.<span class="hljs-title function_">traverse</span>(S, is_anc ? is_anc : <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function>(<span class=hljs-params>node</span>) =&gt;</span> {
            <span class=hljs-keyword>if</span> (i - offset &lt; node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>) {
                <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> node.<span class=hljs-property>elems</span> == <span class=hljs-string>'string'</span>) node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>, i - offset) + v + node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(i - offset + <span class=hljs-number>1</span>)
                <span class=hljs-keyword>else</span> node.<span class=hljs-property>elems</span>[i - offset] = v
                <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
            }
            offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
        })
    }

    sequence.<span class=hljs-property>length</span> = <span class=hljs-function>(<span class=hljs-params>S, is_anc</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> count = <span class=hljs-number>0</span>
        sequence.<span class="hljs-title function_">traverse</span>(S, is_anc ? is_anc : <span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>, <span class=hljs-function><span class=hljs-params>node</span> =&gt;</span> {
            count += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
        })
        <span class=hljs-keyword>return</span> count
    }

    sequence.<span class=hljs-property>break_node</span> = <span class=hljs-function>(<span class=hljs-params>node, x, end_cap, new_next</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> tail = sequence.<span class="hljs-title function_">create_node</span>(<span class=hljs-literal>null</span>, node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(x), node.<span class=hljs-property>end_cap</span>)
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(tail.<span class=hljs-property>deleted_by</span>, node.<span class=hljs-property>deleted_by</span>)
        tail.<span class=hljs-property>nexts</span> = node.<span class=hljs-property>nexts</span>
        tail.<span class=hljs-property>next</span> = node.<span class=hljs-property>next</span>
        
        node.<span class=hljs-property>elems</span> = node.<span class=hljs-property>elems</span>.<span class="hljs-title function_">slice</span>(<span class=hljs-number>0</span>, x)
        node.<span class=hljs-property>end_cap</span> = end_cap
        node.<span class=hljs-property>nexts</span> = new_next ? [new_next] : []
        node.<span class=hljs-property>next</span> = tail

        <span class=hljs-keyword>return</span> tail
    }

    sequence.<span class=hljs-property>add_version</span> = <span class=hljs-function>(<span class=hljs-params>S, version, splices, is_anc</span>) =&gt;</span> {

        <span class=hljs-keyword>var</span> rebased_splices = []
        
        <span class=hljs-keyword>function</span> <span class="hljs-title function_">add_to_nexts</span>(<span class=hljs-params>nexts, to</span>) {
            <span class=hljs-keyword>var</span> i = <span class="hljs-title function_">binarySearch</span>(nexts, <span class=hljs-keyword>function</span> (<span class=hljs-params>x</span>) {
                <span class=hljs-keyword>if</span> ((to.<span class=hljs-property>sort_key</span> || to.<span class=hljs-property>version</span>) &lt; (x.<span class=hljs-property>sort_key</span> || x.<span class=hljs-property>version</span>)) <span class=hljs-keyword>return</span> -<span class=hljs-number>1</span>
                <span class=hljs-keyword>if</span> ((to.<span class=hljs-property>sort_key</span> || to.<span class=hljs-property>version</span>) &gt; (x.<span class=hljs-property>sort_key</span> || x.<span class=hljs-property>version</span>)) <span class=hljs-keyword>return</span> <span class=hljs-number>1</span>
                <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>
            })
            nexts.<span class="hljs-title function_">splice</span>(i, <span class=hljs-number>0</span>, to)
        }
        
        <span class=hljs-keyword>var</span> si = <span class=hljs-number>0</span>
        <span class=hljs-keyword>var</span> delete_up_to = <span class=hljs-number>0</span>
        
        <span class=hljs-keyword>var</span> <span class="hljs-title function_">process_patch</span> = (<span class=hljs-params>node, offset, has_nexts, prev, _version, deleted</span>) =&gt; {
            <span class=hljs-keyword>var</span> s = splices[si]
            <span class=hljs-keyword>if</span> (!s) <span class=hljs-keyword>return</span>
            <span class=hljs-keyword>var</span> sort_key = s[<span class=hljs-number>3</span>]
            
            <span class=hljs-keyword>if</span> (deleted) {
                <span class=hljs-keyword>if</span> (s[<span class=hljs-number>1</span>] == <span class=hljs-number>0</span> &amp;&amp; s[<span class=hljs-number>0</span>] == offset) {
                    <span class=hljs-keyword>if</span> (node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> == <span class=hljs-number>0</span> &amp;&amp; !node.<span class=hljs-property>end_cap</span> &amp;&amp; has_nexts) <span class=hljs-keyword>return</span>
                    <span class=hljs-keyword>var</span> new_node = sequence.<span class="hljs-title function_">create_node</span>(version, s[<span class=hljs-number>2</span>], <span class=hljs-literal>null</span>, sort_key)

                    fresh_nodes.<span class="hljs-title function_">add</span>(new_node)

                    <span class=hljs-keyword>if</span> (node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> == <span class=hljs-number>0</span> &amp;&amp; !node.<span class=hljs-property>end_cap</span>)
                        <span class="hljs-title function_">add_to_nexts</span>(node.<span class=hljs-property>nexts</span>, new_node)
                    <span class=hljs-keyword>else</span>
                        sequence.<span class="hljs-title function_">break_node</span>(node, <span class=hljs-number>0</span>, <span class=hljs-literal>undefined</span>, new_node)
                    si++
                }

                <span class=hljs-keyword>if</span> (delete_up_to &lt;= offset &amp;&amp; s[<span class=hljs-number>1</span>] &amp;&amp; s[<span class=hljs-number>2</span>] &amp;&amp; s[<span class=hljs-number>0</span>] == offset &amp;&amp; node.<span class=hljs-property>end_cap</span> &amp;&amp; !has_nexts &amp;&amp; node.<span class=hljs-property>next</span>?.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>next</span>.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">some</span>(<span class=hljs-function><span class=hljs-params>version</span> =&gt;</span> <span class="hljs-title function_">f</span>(version))) {

                    delete_up_to = s[<span class=hljs-number>0</span>] + s[<span class=hljs-number>1</span>]
                    
                    <span class=hljs-keyword>var</span> new_node = sequence.<span class="hljs-title function_">create_node</span>(version, s[<span class=hljs-number>2</span>], <span class=hljs-literal>null</span>, sort_key)
                    
                    fresh_nodes.<span class="hljs-title function_">add</span>(new_node)

                    <span class="hljs-title function_">add_to_nexts</span>(node.<span class=hljs-property>nexts</span>, new_node)
                }

                <span class=hljs-keyword>return</span>            
            }
            
            <span class=hljs-keyword>if</span> (s[<span class=hljs-number>1</span>] == <span class=hljs-number>0</span>) {
                <span class=hljs-keyword>var</span> d = s[<span class=hljs-number>0</span>] - (offset + node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>)
                <span class=hljs-keyword>if</span> (d &gt; <span class=hljs-number>0</span>) <span class=hljs-keyword>return</span>
                <span class=hljs-keyword>if</span> (d == <span class=hljs-number>0</span> &amp;&amp; !node.<span class=hljs-property>end_cap</span> &amp;&amp; has_nexts) <span class=hljs-keyword>return</span>
                <span class=hljs-keyword>var</span> new_node = sequence.<span class="hljs-title function_">create_node</span>(version, s[<span class=hljs-number>2</span>], <span class=hljs-literal>null</span>, sort_key)

                fresh_nodes.<span class="hljs-title function_">add</span>(new_node)

                <span class=hljs-keyword>if</span> (d == <span class=hljs-number>0</span> &amp;&amp; !node.<span class=hljs-property>end_cap</span>) {
                    <span class="hljs-title function_">add_to_nexts</span>(node.<span class=hljs-property>nexts</span>, new_node)
                } <span class=hljs-keyword>else</span> {
                    sequence.<span class="hljs-title function_">break_node</span>(node, s[<span class=hljs-number>0</span>] - offset, <span class=hljs-literal>undefined</span>, new_node)
                }
                si++
                <span class=hljs-keyword>return</span>
            }
            
            <span class=hljs-keyword>if</span> (delete_up_to &lt;= offset) {
                <span class=hljs-keyword>var</span> d = s[<span class=hljs-number>0</span>] - (offset + node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>)

                <span class=hljs-keyword>let</span> add_at_end = d == <span class=hljs-number>0</span> &amp;&amp; s[<span class=hljs-number>2</span>] &amp;&amp; node.<span class=hljs-property>end_cap</span> &amp;&amp; !has_nexts &amp;&amp; node.<span class=hljs-property>next</span>?.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span> &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>next</span>.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">some</span>(<span class=hljs-function><span class=hljs-params>version</span> =&gt;</span> <span class="hljs-title function_">f</span>(version))

                <span class=hljs-keyword>if</span> (d &gt; <span class=hljs-number>0</span> || (d == <span class=hljs-number>0</span> &amp;&amp; !add_at_end)) <span class=hljs-keyword>return</span>

                delete_up_to = s[<span class=hljs-number>0</span>] + s[<span class=hljs-number>1</span>]
                
                <span class=hljs-keyword>if</span> (s[<span class=hljs-number>2</span>]) {
                    <span class=hljs-keyword>var</span> new_node = sequence.<span class="hljs-title function_">create_node</span>(version, s[<span class=hljs-number>2</span>], <span class=hljs-literal>null</span>, sort_key)

                    fresh_nodes.<span class="hljs-title function_">add</span>(new_node)

                    <span class=hljs-keyword>if</span> (add_at_end) {
                        <span class="hljs-title function_">add_to_nexts</span>(node.<span class=hljs-property>nexts</span>, new_node)
                    } <span class=hljs-keyword>else</span> {
                        sequence.<span class="hljs-title function_">break_node</span>(node, s[<span class=hljs-number>0</span>] - offset, <span class=hljs-literal>true</span>, new_node)
                    }
                    <span class=hljs-keyword>return</span>
                } <span class=hljs-keyword>else</span> {
                    <span class=hljs-keyword>if</span> (s[<span class=hljs-number>0</span>] == offset) {
                    } <span class=hljs-keyword>else</span> {
                        sequence.<span class="hljs-title function_">break_node</span>(node, s[<span class=hljs-number>0</span>] - offset)
                        <span class=hljs-keyword>return</span>
                    }
                }
            }
            
            <span class=hljs-keyword>if</span> (delete_up_to &gt; offset) {
                <span class=hljs-keyword>if</span> (delete_up_to &lt;= offset + node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>) {
                    <span class=hljs-keyword>if</span> (delete_up_to &lt; offset + node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>) {
                        sequence.<span class="hljs-title function_">break_node</span>(node, delete_up_to - offset)
                    }
                    si++
                }
                node.<span class=hljs-property>deleted_by</span>[version] = <span class=hljs-literal>true</span>
                <span class=hljs-keyword>return</span>
            }
        }
        
        <span class=hljs-keyword>var</span> f = is_anc || (<span class=hljs-function>() =&gt;</span> <span class=hljs-literal>true</span>)
        <span class=hljs-keyword>var</span> offset = <span class=hljs-number>0</span>
        <span class=hljs-keyword>var</span> rebase_offset = <span class=hljs-number>0</span>
        <span class=hljs-keyword>let</span> fresh_nodes = <span class=hljs-keyword>new</span> <span class="hljs-title class_">Set</span>()
        <span class=hljs-keyword>function</span> <span class="hljs-title function_">traverse</span>(<span class=hljs-params>node, prev, version</span>) {
            <span class=hljs-keyword>if</span> (!version || <span class="hljs-title function_">f</span>(version)) {
                <span class=hljs-keyword>var</span> has_nexts = node.<span class=hljs-property>nexts</span>.<span class="hljs-title function_">find</span>(<span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class="hljs-title function_">f</span>(next.<span class=hljs-property>version</span>))
                <span class=hljs-keyword>var</span> deleted = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">some</span>(<span class=hljs-function><span class=hljs-params>version</span> =&gt;</span> <span class="hljs-title function_">f</span>(version))
                <span class=hljs-keyword>let</span> rebase_deleted = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class=hljs-property>length</span>
                <span class="hljs-title function_">process_patch</span>(node, offset, has_nexts, prev, version, deleted)

                <span class=hljs-keyword>if</span> (!deleted) offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
                <span class=hljs-keyword>if</span> (!rebase_deleted &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class=hljs-property>length</span>) rebased_splices.<span class="hljs-title function_">push</span>([rebase_offset, node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>, <span class=hljs-string>''</span>])
            }
            <span class=hljs-keyword>if</span> (fresh_nodes.<span class="hljs-title function_">has</span>(node)) rebased_splices.<span class="hljs-title function_">push</span>([rebase_offset, <span class=hljs-number>0</span>, node.<span class=hljs-property>elems</span>])
            <span class=hljs-keyword>if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class=hljs-property>length</span>) rebase_offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>

            <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> next <span class=hljs-keyword>of</span> node.<span class=hljs-property>nexts</span>) <span class="hljs-title function_">traverse</span>(next, <span class=hljs-literal>null</span>, next.<span class=hljs-property>version</span>)
            <span class=hljs-keyword>if</span> (node.<span class=hljs-property>next</span>) <span class="hljs-title function_">traverse</span>(node.<span class=hljs-property>next</span>, node, version)
        }
        <span class="hljs-title function_">traverse</span>(S, <span class=hljs-literal>null</span>, S.<span class=hljs-property>version</span>)

        <span class=hljs-keyword>return</span> rebased_splices
    }

    sequence.<span class=hljs-property>traverse</span> = <span class=hljs-function>(<span class=hljs-params>S, f, cb, view_deleted, tail_cb</span>) =&gt;</span> {
        <span class=hljs-keyword>var</span> exit_early = {}
        <span class=hljs-keyword>var</span> offset = <span class=hljs-number>0</span>
        <span class=hljs-keyword>function</span> <span class="hljs-title function_">helper</span>(<span class=hljs-params>node, prev, version</span>) {
            <span class=hljs-keyword>var</span> has_nexts = node.<span class=hljs-property>nexts</span>.<span class="hljs-title function_">find</span>(<span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class="hljs-title function_">f</span>(next.<span class=hljs-property>version</span>))
            <span class=hljs-keyword>var</span> deleted = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(node.<span class=hljs-property>deleted_by</span>).<span class="hljs-title function_">some</span>(<span class=hljs-function><span class=hljs-params>version</span> =&gt;</span> <span class="hljs-title function_">f</span>(version))
            <span class=hljs-keyword>if</span> (view_deleted || !deleted) {
                <span class=hljs-keyword>if</span> (<span class="hljs-title function_">cb</span>(node, offset, has_nexts, prev, version, deleted) == <span class=hljs-literal>false</span>)
                    <span class=hljs-keyword>throw</span> exit_early
                offset += node.<span class=hljs-property>elems</span>.<span class=hljs-property>length</span>
            }
            <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> next <span class=hljs-keyword>of</span> node.<span class=hljs-property>nexts</span>)
                <span class=hljs-keyword>if</span> (<span class="hljs-title function_">f</span>(next.<span class=hljs-property>version</span>)) <span class="hljs-title function_">helper</span>(next, <span class=hljs-literal>null</span>, next.<span class=hljs-property>version</span>)
            <span class=hljs-keyword>if</span> (node.<span class=hljs-property>next</span>) <span class="hljs-title function_">helper</span>(node.<span class=hljs-property>next</span>, node, version)
            <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (tail_cb) <span class="hljs-title function_">tail_cb</span>(node)
        }
        <span class=hljs-keyword>try</span> {
            <span class="hljs-title function_">helper</span>(S, <span class=hljs-literal>null</span>, S.<span class=hljs-property>version</span>)
        } <span class=hljs-keyword>catch</span> (e) {
            <span class=hljs-keyword>if</span> (e != exit_early) <span class=hljs-keyword>throw</span> e
        }
    }

    <span class=hljs-comment>// modified from https://stackoverflow.com/questions/22697936/binary-search-in-javascript</span>
    <span class=hljs-keyword>function</span> <span class="hljs-title function_">binarySearch</span>(<span class=hljs-params>ar, compare_fn</span>) {
        <span class=hljs-keyword>var</span> m = <span class=hljs-number>0</span>;
        <span class=hljs-keyword>var</span> n = ar.<span class=hljs-property>length</span> - <span class=hljs-number>1</span>;
        <span class=hljs-keyword>while</span> (m &lt;= n) {
            <span class=hljs-keyword>var</span> k = (n + m) &gt;&gt; <span class=hljs-number>1</span>;
            <span class=hljs-keyword>var</span> cmp = <span class="hljs-title function_">compare_fn</span>(ar[k]);
            <span class=hljs-keyword>if</span> (cmp &gt; <span class=hljs-number>0</span>) {
                m = k + <span class=hljs-number>1</span>;
            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span>(cmp &lt; <span class=hljs-number>0</span>) {
                n = k - <span class=hljs-number>1</span>;
            } <span class=hljs-keyword>else</span> {
                <span class=hljs-keyword>return</span> k;
            }
        }
        <span class=hljs-keyword>return</span> m;
    }
})()
</pre></div><h1 style=margin-left:10px;margin-right:10px>json_crdt.descendants(versions, ignore_nonexistent=false)</h1><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowroot]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowroot")});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>